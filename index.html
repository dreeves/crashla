<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- TODO human to vet all user-facing copy (currently Latin placeholders per rule 14) -->
<title>Crashla</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: system-ui, -apple-system, sans-serif;
  line-height: 1.5;
  color: #1a1a1a;
  max-width: 960px;
  margin: 0 auto;
  padding: 1rem;
}
h1 { margin-bottom: 0.5rem; }
h2 { margin: 1.5rem 0 0.75rem; border-bottom: 2px solid #e0e0e0; padding-bottom: 0.25rem; }
h3 { margin: 0.75rem 0 0.5rem; }

/* Rate estimator */
.company-panel {
  border: 1px solid #d0d0d0;
  border-radius: 6px;
  padding: 1rem;
  margin-bottom: 1rem;
  background: #fafafa;
}
.company-panel h3 { margin-top: 0; }
.slider-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin: 0.5rem 0;
}
.slider-row label { min-width: 220px; font-size: 0.9rem; }
.slider-row input[type="range"] { flex: 1; min-width: 120px; }
.slider-row .val { min-width: 100px; text-align: right; font-variant-numeric: tabular-nums; }
.result-box {
  margin-top: 0.75rem;
  padding: 0.75rem;
  background: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  font-variant-numeric: tabular-nums;
}
.result-box .estimate {
  font-size: 1.25rem;
  font-weight: 600;
}
.result-box .ci { font-size: 0.9rem; color: #555; }
.graph-svg {
  width: 100%;
  height: auto;
  display: block;
}
.graph-grid {
  stroke: #e8ecf5;
  stroke-width: 1;
}
.graph-axis {
  stroke: #a7afbf;
  stroke-width: 1;
}
.graph-line {
  fill: none;
  stroke: #2060c0;
  stroke-width: 2;
}
.graph-band {
  fill: rgba(32, 96, 192, 0.18);
}
.graph-point {
  fill: #d13b2d;
  stroke: #fff;
  stroke-width: 2;
}
.graph-refline {
  stroke-width: 1.5;
  stroke-dasharray: 6 4;
}
.graph-reflabel {
  font-size: 10px;
  font-weight: 600;
  paint-order: stroke;
  stroke: #fff;
  stroke-width: 3px;
}
.graph-tick {
  fill: #5b6475;
  font-size: 9px;
}
.graph-label {
  fill: #334;
  font-size: 11px;
}
.ci-bar-container {
  position: relative;
  height: 28px;
  margin: 0.5rem 0;
  background: #f0f0f0;
  border-radius: 4px;
  overflow: hidden;
}
.ci-bar {
  position: absolute;
  height: 100%;
  background: #b0d0ff;
  border-radius: 4px;
}
.ci-median {
  position: absolute;
  width: 3px;
  height: 100%;
  background: #2060c0;
  border-radius: 1px;
}
.ci-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.75rem;
  color: #888;
}

/* Incident browser */
.filters { margin: 0.5rem 0; display: flex; gap: 0.25rem; flex-wrap: wrap; }
.filters button {
  padding: 0.25rem 0.75rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
  font-size: 0.85rem;
}
.filters button.active { background: #2060c0; color: #fff; border-color: #2060c0; }
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
  margin-top: 0.5rem;
}
th, td { padding: 0.35rem 0.5rem; text-align: left; border-bottom: 1px solid #e0e0e0; }
th { background: #f5f5f5; position: sticky; top: 0; }
tr:hover { background: #f8f8ff; }
.narrative-cell {
  max-width: 300px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  cursor: pointer;
}
.narrative-cell.expanded { white-space: normal; }
.cbi { color: #999; font-style: italic; }
.incident-count { font-size: 0.9rem; color: #666; margin: 0.25rem 0; }
</style>
</head>
<body>

<h1>Tesla vs Waymo vs Zoox vs Humans</h1>

<div id="estimator"></div>

<!-- TODO human to vet section heading — "Incident browser" -->
<h2>Incident browser</h2>
<div class="filters" id="filters"></div>
<div class="incident-count" id="incident-count"></div>
<div style="overflow-x: auto;">
  <table>
    <thead>
      <tr>
        <!-- TODO human to vet column headers — "Company", "Date", "Location", "Crash with", "Speed (mph)", "Severity", "Narrative" -->
        <th>Company</th>
        <th>Date</th>
        <th>Location</th>
        <th>Crash with</th>
        <th>Speed (mph)</th>
        <th>Severity</th>
        <th>Narrative</th>
      </tr>
    </thead>
    <tbody id="incidents-body"></tbody>
  </table>
</div>

<script>
"use strict";

function fail(msg, details) {
  const suffix = details === undefined ? "" : " " + JSON.stringify(details);
  throw new Error(msg + suffix);
}

function must(cond, msg, details) {
  cond || fail(msg, details);
}

function byId(id) {
  const node = document.getElementById(id);
  must(node !== null, "Missing required DOM node", {id});
  return node;
}

// --- Gamma distribution math ---

// Log-gamma via Lanczos approximation (g=7, n=9)
const LANCZOS_C = [
  0.99999999999980993, 676.5203681218851, -1259.1392167224028,
  771.32342877765313, -176.61502916214059, 12.507343278686905,
  -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7
];
function lgamma(x) {
  if (x < 0.5) return Math.log(Math.PI / Math.sin(Math.PI * x)) - lgamma(1 - x);
  x -= 1;
  let a = LANCZOS_C[0];
  const t = x + 7.5; // g + 0.5
  for (let i = 1; i < 9; i++) a += LANCZOS_C[i] / (x + i);
  return 0.5 * Math.log(2 * Math.PI) + (x + 0.5) * Math.log(t) - t + Math.log(a);
}

// Lower regularized incomplete gamma function P(a, x)
// Series expansion for x < a + 1, continued fraction otherwise
function gammainc(a, x) {
  if (x < 0) return 0;
  if (x === 0) return 0;
  if (x < a + 1) {
    // Series: P(a,x) = e^{-x} x^a sum_{n=0}^{inf} x^n / Gamma(a+n+1)
    let sum = 1 / a;
    let term = 1 / a;
    for (let n = 1; n < 200; n++) {
      term *= x / (a + n);
      sum += term;
      if (Math.abs(term) < Math.abs(sum) * 1e-14) break;
    }
    return sum * Math.exp(-x + a * Math.log(x) - lgamma(a));
  }
  // Continued fraction for upper gamma Q(a,x) = 1 - P(a,x)
  // Using modified Lentz's method
  let f = x - a + 1;
  if (Math.abs(f) < 1e-30) f = 1e-30;
  let c = f;
  let d = 0;
  for (let n = 1; n < 200; n++) {
    const an = n * (a - n);
    const bn = x - a + 1 + 2 * n;
    d = bn + an * d;
    if (Math.abs(d) < 1e-30) d = 1e-30;
    c = bn + an / c;
    if (Math.abs(c) < 1e-30) c = 1e-30;
    d = 1 / d;
    const delta = c * d;
    f *= delta;
    if (Math.abs(delta - 1) < 1e-14) break;
  }
  const q = Math.exp(-x + a * Math.log(x) - lgamma(a)) / f;
  return 1 - q;
}

// Gamma quantile: find x such that P(a, x*b) = p, where Gamma(a, b) has rate b
// Returns x (the quantile of Gamma(shape=a, rate=b))
function gammaquant(a, b, p) {
  must(a > 0 && b > 0 && p > 0 && p < 1,
    "gammaquant: invalid params", {a, b, p});
  // Initial guess via Wilson-Hilferty approximation on chi-squared
  const nu = 2 * a;
  // Normal quantile approximation (Abramowitz & Stegun 26.2.23)
  const t = p < 0.5 ? p : 1 - p;
  const s = Math.sqrt(-2 * Math.log(t));
  let zabs = s - (2.515517 + 0.802853*s + 0.010328*s*s) /
                   (1 + 1.432788*s + 0.189269*s*s + 0.001308*s*s*s);
  const z = p < 0.5 ? -zabs : zabs;
  // Wilson-Hilferty
  const wh = 1 - 2/(9*nu) + z * Math.sqrt(2/(9*nu));
  let x = (nu / 2) * Math.max(wh * wh * wh, 0.001) / b;
  // Newton's method to refine
  for (let i = 0; i < 50; i++) {
    const cdf = gammainc(a, x * b);
    const err = cdf - p;
    if (Math.abs(err) < 1e-12) break;
    // PDF of Gamma(a, b): b^a x^{a-1} e^{-bx} / Gamma(a)
    const logpdf = a * Math.log(b) + (a-1) * Math.log(x) - b*x - lgamma(a);
    const pdf = Math.exp(logpdf);
    if (pdf < 1e-100) break; // avoid division by ~0
    const step = err / pdf;
    x = Math.max(x - step, x / 10); // don't go negative or overshoot
  }
  return x;
}

// Compute miles-per-incident estimate with 90% credible interval
// k = incident count, m = miles driven
function estimateRate(k, m, phi = 1) {
  must(phi >= 1, "phi must be at least 1", {phi});
  const a = (k + 0.5) / phi; // posterior shape, deflated by VIF
  const b = m / phi;          // posterior rate, deflated by VIF
  const tail = (1 - CI_MASS) / 2;
  // Median of 1/lambda = 1 / median(lambda)
  const medianLambda = gammaquant(a, b, 0.5);
  const loLambda     = gammaquant(a, b, 1 - tail);
  const hiLambda     = gammaquant(a, b, tail);
  return {
    median: 1 / medianLambda,
    lo:     1 / loLambda,   // lower bound of miles-per-incident
    hi:     1 / hiLambda,   // upper bound of miles-per-incident
  };
}

// --- Data and UI ---

let incidents = [];
const CI_MASS = 0.95;
const COMPANY_COLORS = {
  Tesla: "#d13b2d",
  Waymo: "#2a8f57",
  Zoox: "#b7771a",
  Humans: "#5b6475",
};
const COMPANY_ORDER = ["Tesla", "Waymo", "Zoox", "Humans"];
const INCIDENT_MODEL_COMPANIES = ["Tesla", "Waymo", "Zoox"];
const AXIS_MIN_DEFAULT_PCT = 0;
const AXIS_MAX_DEFAULT_PCT = 100;
// TO-DO human to vet axis-slider copy.
const AXIS_MIN_LABEL = "X-axis minimum";
// TO-DO human to vet axis-slider copy.
const AXIS_MAX_LABEL = "X-axis maximum";
// TO-DO human to vet axis-slider copy.
const AXIS_MIN_TIP = "Choose the lower x-axis bound for this graph.";
// TO-DO human to vet axis-slider copy.
const AXIS_MAX_TIP = "Choose the upper x-axis bound for this graph.";
// Tesla pre-Sep-1 miles (all empty driver's seat)
const TESLA_PRE_SEP_MILES = 93849;

function pct(v) {
  return v / 100;
}

function deadheadMultiplier(deadheadPct) {
  const deadheadFrac = pct(deadheadPct);
  must(deadheadFrac >= 0 && deadheadFrac < 1,
    "deadhead share out of range", {deadheadPct});
  return 1 / (1 - deadheadFrac);
}

function factorizedParts(baseMiles, deadheadPct) {
  const baseNoneMiles = baseMiles;
  const mDeadhead = deadheadMultiplier(deadheadPct);
  return {
    baseMiles,
    baseNoneMiles,
    deadheadPct,
    deadheadMultiplier: mDeadhead,
    miles: baseNoneMiles * mDeadhead,
  };
}

function scaleEstimate(est, factor) {
  return {
    median: est.median * factor,
    lo: est.lo * factor,
    hi: est.hi * factor,
  };
}

function axisInputId(company, edge) {
  return `x-${edge}-${company}`;
}

function axisValueId(company, edge) {
  return `x-${edge}-${company}-val`;
}

// Company configs: incident count from data, slider definitions
const COMPANIES = {
  Tesla: {
    sliders: [
      {
        id: "tesla-miles",
        // TODO human to vet label — "Total robotaxi miles"
        // TO-DO human to vet tooltip text.
        label: "Total robotaxi miles",
        tip: "Base robotaxi miles in this window before applying non-service factors.",
        min: 94000, max: 600000, step: 1000, value: 450000,
        fmt: v => v.toLocaleString(),
      },
      {
        id: "tesla-frac",
        // TODO human to vet label — "% post-Sep-1 without driver"
        // TO-DO human to vet tooltip text.
        label: "% post-Sep-1 without driver",
        tip: "Share of post-Sep-1 miles where the driver seat is empty.",
        min: 0, max: 100, step: 1, value: 70,
        fmt: v => v + "%",
      },
      {
        id: "tesla-deadhead",
        // TO-DO human to vet label — "Non-service share (deadhead)"
        // TO-DO human to vet tooltip text.
        label: "Non-service share",
        tip: "Share of ADS miles with no passenger in the car; used for the non-service multiplier.",
        min: 0, max: 40, step: 1, value: 20,
        fmt: v => v + "%",
      },
      {
        id: "tesla-vif",
        // TO-DO human to vet label — "Superdispersio (φ)"
        // TO-DO human to vet tooltip text.
        label: "Overdispersion (φ)",
        tip: "Variance inflation factor: 1× = Poisson; higher values widen intervals for rate variability.",
        min: 1, max: 5, step: 0.5, value: 1,
        fmt: v => v.toFixed(1).replace(/\.0$/, "") + "×",
      },
    ],
    getParts: vals => {
      const baseMiles = vals["tesla-miles"];
      must(baseMiles >= TESLA_PRE_SEP_MILES,
        "tesla base miles below pre-Sep-1 miles", {baseMiles});
      const nonePostPct = vals["tesla-frac"];
      const postSepMiles = baseMiles - TESLA_PRE_SEP_MILES;
      const baseNoneMiles = TESLA_PRE_SEP_MILES + pct(nonePostPct) * postSepMiles;
      const deadheadPct = vals["tesla-deadhead"];
      const mDeadhead = deadheadMultiplier(deadheadPct);
      return {
        baseMiles,
        baseNoneMiles,
        deadheadPct,
        deadheadMultiplier: mDeadhead,
        miles: baseNoneMiles * mDeadhead,
      };
    },
  },
  Waymo: {
    sliders: [
      {
        id: "waymo-miles",
        // TODO human to vet label — "Driverless miles"
        // TO-DO human to vet tooltip text.
        label: "Driverless miles",
        tip: "Waymo base miles in this window before non-service adjustment.",
        min: 57000000, max: 66000000, step: 1000000, value: 61000000,
        fmt: v => (v / 1e6).toFixed(0) + "M",
      },
      {
        id: "waymo-deadhead",
        // TO-DO human to vet label — "Non-service share (deadhead)"
        // TO-DO human to vet tooltip text.
        label: "Non-service share",
        tip: "Share of ADS miles with no passenger in the car; used for the non-service multiplier.",
        min: 0, max: 50, step: 1, value: 0,
        fmt: v => v + "%",
      },
      {
        id: "waymo-vif",
        // TO-DO human to vet label — "Superdispersio (φ)"
        // TO-DO human to vet tooltip text.
        label: "Overdispersion (φ)",
        tip: "Variance inflation factor: 1× = Poisson; higher values widen intervals for rate variability.",
        min: 1, max: 5, step: 0.5, value: 1,
        fmt: v => v.toFixed(1).replace(/\.0$/, "") + "×",
      },
    ],
    getParts: vals => factorizedParts(
      vals["waymo-miles"],
      vals["waymo-deadhead"],
    ),
  },
  Zoox: {
    sliders: [
      {
        id: "zoox-miles",
        // TODO human to vet label — "Driverless miles"
        // TO-DO human to vet tooltip text.
        label: "Driverless miles",
        tip: "Zoox base miles in this window before non-service adjustment.",
        min: 50000, max: 1000000, step: 25000, value: 300000,
        fmt: v => v.toLocaleString(),
      },
      {
        id: "zoox-deadhead",
        // TO-DO human to vet label — "Non-service share (deadhead)"
        // TO-DO human to vet tooltip text.
        label: "Non-service share",
        tip: "Share of ADS miles with no passenger; converts service miles to total VMT.",
        min: 0, max: 40, step: 1, value: 20,
        fmt: v => v + "%",
      },
      {
        id: "zoox-vif",
        // TO-DO human to vet label — "Superdispersio (φ)"
        // TO-DO human to vet tooltip text.
        label: "Overdispersion (φ)",
        tip: "Variance inflation factor: 1× = Poisson; higher values widen intervals for rate variability.",
        min: 1, max: 5, step: 0.5, value: 1,
        fmt: v => v.toFixed(1).replace(/\.0$/, "") + "×",
      },
    ],
    getParts: vals => factorizedParts(
      vals["zoox-miles"],
      vals["zoox-deadhead"],
    ),
  },
  Humans: {
    sliders: [
      {
        id: "humans-waymo-divisor",
        // TO-DO human to vet label — "Humans as 1/x of Waymo miles per incident"
        // TO-DO human to vet tooltip text.
        label: "Humans as 1/x of Waymo miles per incident",
        tip: "Set humans to one-over-x of Waymo miles per incident; range is 1/2 to 1/10.",
        min: 2, max: 10, step: 0.1, value: 5,
        fmt: v => "1/" + Number(v).toFixed(1).replace(/\\.0$/, "") + "x",
      },
    ],
  },
};

// Count incidents per company from loaded data
function countByCompany() {
  const counts = {};
  for (const inc of incidents) {
    counts[inc.company] = (counts[inc.company] || 0) + 1;
  }
  return counts;
}

function primarySliderBounds(cfg, vals) {
  const primary = cfg.sliders[0];
  must(primary !== undefined, "missing primary slider for bounds");
  const loVals = {...vals, [primary.id]: primary.min};
  const hiVals = {...vals, [primary.id]: primary.max};
  const lo = cfg.getParts(loVals).miles;
  const hi = cfg.getParts(hiVals).miles;
  return {
    min: Math.min(lo, hi),
    max: Math.max(lo, hi),
  };
}

function scaleLinear(v, d0, d1, r0, r1) {
  const span = (d1 - d0) || 1;
  return r0 + (v - d0) * (r1 - r0) / span;
}

function sampledEstimates(estAtMiles, xMin, xMax, n) {
  const out = [];
  for (let i = 0; i <= n; i++) {
    const x = xMin + (xMax - xMin) * i / n;
    out.push({x, est: estAtMiles(x)});
  }
  return out;
}

function medianPath(samples, mapX, mapY) {
  let d = "";
  for (let i = 0; i < samples.length; i++) {
    const s = samples[i];
    d += `${i ? " L " : "M "}${mapX(s.x).toFixed(2)} ${mapY(s.est.median).toFixed(2)}`;
  }
  return d;
}

function bandPath(samples, mapX, mapY) {
  let d = "";
  for (let i = 0; i < samples.length; i++) {
    const s = samples[i];
    d += `${i ? " L " : "M "}${mapX(s.x).toFixed(2)} ${mapY(s.est.hi).toFixed(2)}`;
  }
  for (let i = samples.length - 1; i >= 0; i--) {
    const s = samples[i];
    d += ` L ${mapX(s.x).toFixed(2)} ${mapY(s.est.lo).toFixed(2)}`;
  }
  return d + " Z";
}

function layoutRefLabels(peers, mapY, top, height) {
  const minGap = 12;
  const yMin = top + 10;
  const yMax = top + height - 4;
  const laid = peers
    .map(peer => ({
      ...peer,
      lineY: mapY(peer.est.median),
      labelY: 0,
    }))
    .sort((a, b) => a.lineY - b.lineY)
    .map(peer => ({
      ...peer,
      labelY: Math.min(Math.max(peer.lineY - 4, yMin), yMax),
    }));

  for (let pass = 0; pass < 3; pass++) {
    for (let i = 1; i < laid.length; i++) {
      laid[i].labelY = Math.max(laid[i].labelY, laid[i - 1].labelY + minGap);
    }
    for (let i = laid.length - 2; i >= 0; i--) {
      laid[i].labelY = Math.min(laid[i].labelY, laid[i + 1].labelY - minGap);
    }
    for (const peer of laid) {
      peer.labelY = Math.min(Math.max(peer.labelY, yMin), yMax);
    }
  }

  return peers.map(peer => {
    const hit = laid.find(candidate => candidate.company === peer.company);
    must(hit !== undefined, "missing laid-out peer label", {company: peer.company});
    return hit;
  });
}

function axisWindow(company, bounds) {
  const minRaw = byId(axisInputId(company, "min")).value;
  const maxRaw = byId(axisInputId(company, "max")).value;
  const minPct = minRaw === "" ? AXIS_MIN_DEFAULT_PCT : Number(minRaw);
  const maxPct = maxRaw === "" ? AXIS_MAX_DEFAULT_PCT : Number(maxRaw);
  must(Number.isFinite(minPct) && Number.isFinite(maxPct),
    "axis slider values must be finite", {company, minRaw, maxRaw});
  must(minPct >= 0 && minPct <= 99 && maxPct >= 1 && maxPct <= 100,
    "axis slider values out of range", {company, minPct, maxPct});
  must(minPct < maxPct,
    "axis min must be lower than axis max", {company, minPct, maxPct});
  const span = bounds.max - bounds.min;
  return {
    minPct,
    maxPct,
    xMin: bounds.min + span * (minPct / 100),
    xMax: bounds.min + span * (maxPct / 100),
  };
}

function syncAxisSliderBounds(company) {
  const minInput = byId(axisInputId(company, "min"));
  const maxInput = byId(axisInputId(company, "max"));
  const minPct = minInput.value === "" ? AXIS_MIN_DEFAULT_PCT : Number(minInput.value);
  const maxPct = maxInput.value === "" ? AXIS_MAX_DEFAULT_PCT : Number(maxInput.value);
  must(Number.isFinite(minPct) && Number.isFinite(maxPct),
    "axis slider values must be finite", {company, minPct, maxPct});
  must(minPct < maxPct,
    "axis min must be lower than axis max", {company, minPct, maxPct});
  minInput.max = String(maxPct - 1);
  maxInput.min = String(minPct + 1);
}

function sliderVals(cfg) {
  const vals = {};
  for (const s of cfg.sliders) {
    const raw = byId(s.id).value;
    const parsed = raw === "" ? s.value : Number(raw);
    must(Number.isFinite(parsed), "slider value must be finite", {id: s.id, raw});
    vals[s.id] = parsed;
  }
  return vals;
}

function summaryFromIncidentModel(company, counts, valsByCompany) {
  const cfg = COMPANIES[company];
  const vals = valsByCompany[company];
  const miles = cfg.getParts(vals).miles;
  const k = counts[company] || 0;
  const phi = vals[company.toLowerCase() + "-vif"];
  const estAtMiles = x => estimateRate(k, x, phi);
  return {
    company,
    k,
    miles,
    est: estAtMiles(miles),
    estAtMiles,
    bounds: primarySliderBounds(cfg, vals),
  };
}

function companySummaries(counts) {
  const valsByCompany = {};
  for (const company of COMPANY_ORDER) {
    valsByCompany[company] = sliderVals(COMPANIES[company]);
  }

  const summaries = {};
  for (const company of INCIDENT_MODEL_COMPANIES) {
    summaries[company] = summaryFromIncidentModel(company, counts, valsByCompany);
  }

  const waymo = summaries.Waymo;
  must(waymo !== undefined, "Humans summary requires Waymo summary");
  const waymoDivisor = valsByCompany.Humans["humans-waymo-divisor"];
  must(waymoDivisor >= 2 && waymoDivisor <= 10,
    "Humans/Waymo divisor out of range", {waymoDivisor});
  const humanFactor = 1 / waymoDivisor;
  const estAtMiles = miles => scaleEstimate(waymo.estAtMiles(miles), humanFactor);
  summaries.Humans = {
    company: "Humans",
    k: waymo.k,
    miles: waymo.miles,
    est: estAtMiles(waymo.miles),
    estAtMiles,
    bounds: waymo.bounds,
    waymoDivisor,
  };
  return summaries;
}

function fmtDivisor(divisor) {
  return "1/" + Number(divisor).toFixed(1).replace(/\\.0$/, "");
}

function summaryHeader(summary) {
  // TO-DO human to vet header copy for the Humans panel.
  const formatters = {
    Tesla: s =>
      `${s.company}: ${s.k} incidents in ${Math.round(s.miles).toLocaleString()} miles ⇒ ${fmtMiles(s.est.median)} miles per incident`,
    Waymo: s =>
      `${s.company}: ${s.k} incidents in ${Math.round(s.miles).toLocaleString()} miles ⇒ ${fmtMiles(s.est.median)} miles per incident`,
    Zoox: s =>
      `${s.company}: ${s.k} incidents in ${Math.round(s.miles).toLocaleString()} miles ⇒ ${fmtMiles(s.est.median)} miles per incident`,
    Humans: s =>
      `Humans: ${fmtMiles(s.est.median)} miles per incident (${fmtDivisor(s.waymoDivisor)} of Waymo)`,
  };
  const fn = formatters[summary.company];
  must(typeof fn === "function", "Missing summary header formatter", {company: summary.company});
  return fn(summary);
}

function updateAllEstimates() {
  for (const company of COMPANY_ORDER) updateEstimate(company);
}

function buildEstimator() {
  const container = byId("estimator");
  container.replaceChildren();
  const counts = countByCompany();

  for (const company of COMPANY_ORDER) {
    const cfg = COMPANIES[company];
    const k = counts[company] || 0;
    const panel = document.createElement("div");
    panel.className = "company-panel";
    panel.dataset.company = company;

    // TODO human to vet — "incidents"
    let html = `<h3 id="header-stats-${company}">${company}: ${k} incidents in 0 miles ⇒ ? miles per incident</h3>`;

    for (const s of cfg.sliders) {
      must(typeof s.tip === "string" && s.tip.length > 0,
        "slider missing tooltip", {company, sliderId: s.id});
      const tip = escAttr(s.tip);
      html += `
        <div class="slider-row">
          <label for="${s.id}" title="${tip}">${s.label}</label>
          <input type="range" id="${s.id}" min="${s.min}" max="${s.max}"
                 step="${s.step}" value="${s.value}" title="${tip}">
          <span class="val" id="${s.id}-val">${s.fmt(s.value)}</span>
        </div>`;
    }

    const axisMinTip = escAttr(AXIS_MIN_TIP);
    const axisMaxTip = escAttr(AXIS_MAX_TIP);
    const axisMinInput = axisInputId(company, "min");
    const axisMaxInput = axisInputId(company, "max");
    const axisMinValue = axisValueId(company, "min");
    const axisMaxValue = axisValueId(company, "max");
    html += `
      <div class="slider-row">
        <label for="${axisMinInput}" title="${axisMinTip}">${AXIS_MIN_LABEL}</label>
        <input type="range" id="${axisMinInput}" min="0" max="99" step="1"
               value="${AXIS_MIN_DEFAULT_PCT}" title="${axisMinTip}">
        <span class="val" id="${axisMinValue}">0</span>
      </div>
      <div class="slider-row">
        <label for="${axisMaxInput}" title="${axisMaxTip}">${AXIS_MAX_LABEL}</label>
        <input type="range" id="${axisMaxInput}" min="1" max="100" step="1"
               value="${AXIS_MAX_DEFAULT_PCT}" title="${axisMaxTip}">
        <span class="val" id="${axisMaxValue}">0</span>
      </div>`;

    html += `<div class="result-box" id="result-${company}"></div>`;
    panel.innerHTML = html;
    container.appendChild(panel);

    // Attach slider listeners
    for (const s of cfg.sliders) {
      const input = byId(s.id);
      const valSpan = byId(s.id + "-val");
      input.addEventListener("input", () => {
        valSpan.textContent = s.fmt(Number(input.value));
        updateAllEstimates();
      });
    }
    const axisMinNode = byId(axisInputId(company, "min"));
    const axisMaxNode = byId(axisInputId(company, "max"));
    syncAxisSliderBounds(company);
    axisMinNode.addEventListener("input", () => {
      syncAxisSliderBounds(company);
      updateAllEstimates();
    });
    axisMaxNode.addEventListener("input", () => {
      syncAxisSliderBounds(company);
      updateAllEstimates();
    });
  }
  updateAllEstimates();
}

function updateEstimate(company) {
  const cfg = COMPANIES[company];
  must(cfg !== undefined, "Unknown company config", {company});
  const counts = countByCompany();
  const summaries = companySummaries(counts);
  const thisSummary = summaries[company];
  must(thisSummary !== undefined, "Missing summary for company", {company});
  const peers = COMPANY_ORDER.filter(name => name !== company).map(name => summaries[name]);
  const miles = thisSummary.miles;
  const est = thisSummary.est;
  byId("header-stats-" + company).textContent = summaryHeader(thisSummary);

  const box = byId("result-" + company);
  const axis = axisWindow(company, thisSummary.bounds);
  const xMin = axis.xMin;
  const xMax = axis.xMax;
  byId(axisValueId(company, "min")).textContent = Math.round(xMin).toLocaleString();
  byId(axisValueId(company, "max")).textContent = Math.round(xMax).toLocaleString();
  const samples = sampledEstimates(thisSummary.estAtMiles, xMin, xMax, 40);
  const yMin = Math.min(...samples.map(s => s.est.lo), ...peers.map(p => p.est.median));
  const yMax = Math.max(...samples.map(s => s.est.hi), ...peers.map(p => p.est.median));
  const svgW = 520;
  const svgH = 220;
  const mLeft = 56;
  const mRight = 12;
  const mTop = 10;
  const mBot = 40;
  const pW = svgW - mLeft - mRight;
  const pH = svgH - mTop - mBot;
  const mapX = x => scaleLinear(x, xMin, xMax, mLeft, mLeft + pW);
  const mapY = y => scaleLinear(y, yMin, yMax, mTop + pH, mTop);
  const pointX = mapX(miles);
  const pointY = mapY(est.median);
  const xTicks = [xMin, (xMin + xMax) / 2, xMax];
  const xTickAnchors = ["start", "middle", "end"];
  const yTicks = [yMin, (yMin + yMax) / 2, yMax];
  const band = bandPath(samples, mapX, mapY);
  const path = medianPath(samples, mapX, mapY);
  const peerLabels = layoutRefLabels(peers, mapY, mTop, pH);

  // TODO human to vet — "X miles between incidents",
  //   "90% credible interval: lo – hi", "Effective miles: N · Incidents: K"
  // TO-DO human to vet denominator component copy.
  // TO-DO human to vet graph axis copy.
  box.innerHTML = `
    <svg class="graph-svg" viewBox="0 0 ${svgW} ${svgH}">
      ${xTicks.map((x, i) => `
        <line class="graph-grid" x1="${mapX(x)}" y1="${mTop}" x2="${mapX(x)}" y2="${mTop + pH}"></line>
        <text class="graph-tick" x="${mapX(x)}" y="${svgH - 16}" text-anchor="${xTickAnchors[i]}">${Math.round(x).toLocaleString()}</text>
      `).join("")}
      ${yTicks.map(y => `
        <line class="graph-grid" x1="${mLeft}" y1="${mapY(y)}" x2="${mLeft + pW}" y2="${mapY(y)}"></line>
        <text class="graph-tick" x="${mLeft - 8}" y="${mapY(y) + 4}" text-anchor="end">${fmtMiles(y)}</text>
      `).join("")}
      <line class="graph-axis" x1="${mLeft}" y1="${mTop}" x2="${mLeft}" y2="${mTop + pH}"></line>
      <line class="graph-axis" x1="${mLeft}" y1="${mTop + pH}" x2="${mLeft + pW}" y2="${mTop + pH}"></line>
      <path class="graph-band" d="${band}"></path>
      <path class="graph-line" d="${path}"></path>
      ${peerLabels.map(p => `
        <line class="graph-refline" x1="${mLeft}" y1="${p.lineY}" x2="${mLeft + pW}" y2="${p.lineY}" style="stroke:${COMPANY_COLORS[p.company]}"></line>
        <text class="graph-reflabel" x="${mLeft + pW - 4}" y="${p.labelY}" text-anchor="end" style="fill:${COMPANY_COLORS[p.company]}">${p.company}: ${fmtMiles(p.est.median)}</text>
      `).join("")}
      <circle class="graph-point" cx="${pointX}" cy="${pointY}" r="5"></circle>
      <text class="graph-label" x="${mLeft + pW / 2}" y="${svgH - 2}" text-anchor="middle">Total Autonomous Miles</text>
      <text class="graph-label" x="12" y="${mTop + pH / 2}" transform="rotate(-90 12 ${mTop + pH / 2})" text-anchor="middle">Miles per incident</text>
    </svg>
  `;
}

function fmtMiles(n) {
  if (n >= 1e6) return (n / 1e6).toFixed(1) + "M";
  if (n >= 1e3) return (n / 1e3).toFixed(1) + "K";
  return Math.round(n).toLocaleString();
}

// --- Incident Browser ---

let activeFilter = "All";

function buildBrowser() {
  const counts = countByCompany();
  const filterDiv = byId("filters");
  filterDiv.replaceChildren();
  // TODO human to vet button labels — "All", "Tesla", "Waymo", "Zoox" (these are just company names + "All")
  const companies = ["All", ...COMPANY_ORDER];
  for (const c of companies) {
    const btn = document.createElement("button");
    const n = c === "All" ? incidents.length : (counts[c] || 0);
    btn.textContent = `${c} (${n})`;
    btn.className = c === activeFilter ? "active" : "";
    btn.addEventListener("click", () => {
      activeFilter = c;
      buildBrowser();
    });
    filterDiv.appendChild(btn);
  }
  renderTable();
}

function renderTable() {
  const tbody = byId("incidents-body");
  const filtered = activeFilter === "All"
    ? incidents
    : incidents.filter(r => r.company === activeFilter);

  byId("incident-count").textContent =
    `${filtered.length} incidents`; // TODO human to vet — "N incidents"

  tbody.innerHTML = "";
  for (const r of filtered) {
    const tr = document.createElement("tr");
    const isCbi = r.narrativeCbi === "Y";
    const narrativeText = isCbi
      // TO-DO human to vet acronym expansion copy.
      ? "[\"Confidential Business Information\"]"
      : (r.narrative || "");
    const narrativeClass = isCbi ? "narrative-cell cbi" : "narrative-cell";

    tr.innerHTML = `
      <td>${escHtml(r.company)}</td>
      <td>${escHtml(r.date)}</td>
      <td>${escHtml(r.city)}, ${escHtml(r.state)}</td>
      <td>${escHtml(r.crashWith)}</td>
      <td>${escHtml(r.speed !== null ? String(r.speed) : "?")}</td>
      <td>${escHtml(shortenSeverity(r.severity))}</td>
      <td class="${narrativeClass}">${escHtml(narrativeText)}</td>
    `;
    // Click to expand/collapse narrative
    const narrativeTd = tr.querySelector(".narrative-cell");
    must(narrativeTd !== null, "Missing narrative cell");
    narrativeTd.addEventListener("click", () => {
      narrativeTd.classList.toggle("expanded");
    });
    tbody.appendChild(tr);
  }
}

function shortenSeverity(s) {
  const rules = [
    ["No Injured", "No injury"],
    ["Minor W/O", "Minor injury"],
    ["Minor W/", "Minor injury (hosp.)"],
    ["Serious", "Serious"],
    ["Fatal", "Fatal"],
    ["Property", "Property only"],
  ];
  const hit = (s || "") && rules.find(([needle]) => s.includes(needle));
  return hit ? hit[1] : (s || "?");
}

function escHtml(s) {
  const d = document.createElement("div");
  d.textContent = s;
  return d.innerHTML;
}

function escAttr(s) {
  return escHtml(s).replace(/"/g, "&quot;");
}

// --- Init ---

fetch("incidents.json")
  .then(r => (must(r.ok, "Failed to load incidents.json", {status: r.status}), r.json()))
  .then(data => {
    must(Array.isArray(data), "incidents.json must be an array");
    for (const inc of data) {
      must(inc !== null && typeof inc === "object", "incident must be an object");
      must(typeof inc.company === "string", "incident missing company");
      must(COMPANIES[inc.company] !== undefined,
        "incidents.json has unknown company", {company: inc.company});
    }
    incidents = data;
    buildEstimator();
    buildBrowser();
  });
</script>
</body>
</html>
