<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- TODO human to vet all user-facing copy (currently Latin placeholders per rule 14) -->
<title>Crashla</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: system-ui, -apple-system, sans-serif;
  line-height: 1.5;
  color: #1a1a1a;
  max-width: 960px;
  margin: 0 auto;
  padding: 1rem;
}
h1 { margin-bottom: 0.5rem; }
h2 { margin: 1.5rem 0 0.75rem; border-bottom: 2px solid #e0e0e0; padding-bottom: 0.25rem; }
h3 { margin: 0.75rem 0 0.5rem; }

/* Rate estimator */
.company-panel {
  border: 1px solid #d0d0d0;
  border-radius: 6px;
  padding: 1rem;
  margin-bottom: 1rem;
  background: #fafafa;
}
.company-panel h3 { margin-top: 0; }
.slider-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin: 0.5rem 0;
}
.slider-row label { min-width: 220px; font-size: 0.9rem; }
.slider-row input[type="range"] { flex: 1; min-width: 120px; }
.slider-row .val { min-width: 100px; text-align: right; font-variant-numeric: tabular-nums; }
.result-box {
  margin-top: 0.75rem;
  padding: 0.75rem;
  background: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  font-variant-numeric: tabular-nums;
}
.result-box .estimate {
  font-size: 1.25rem;
  font-weight: 600;
}
.result-box .ci { font-size: 0.9rem; color: #555; }
.graph-svg {
  width: 100%;
  height: auto;
  display: block;
}
.graph-grid {
  stroke: #e8ecf5;
  stroke-width: 1;
}
.graph-axis {
  stroke: #a7afbf;
  stroke-width: 1;
}
.graph-line {
  fill: none;
  stroke: #2060c0;
  stroke-width: 2;
}
.graph-band {
  fill: rgba(32, 96, 192, 0.18);
}
.graph-point {
  fill: #d13b2d;
  stroke: #fff;
  stroke-width: 2;
}
.graph-refline {
  stroke-width: 1.5;
  stroke-dasharray: 6 4;
}
.graph-reflabel {
  font-size: 10px;
  font-weight: 600;
}
.graph-tick {
  fill: #5b6475;
  font-size: 10px;
}
.graph-label {
  fill: #334;
  font-size: 11px;
}
.ci-bar-container {
  position: relative;
  height: 28px;
  margin: 0.5rem 0;
  background: #f0f0f0;
  border-radius: 4px;
  overflow: hidden;
}
.ci-bar {
  position: absolute;
  height: 100%;
  background: #b0d0ff;
  border-radius: 4px;
}
.ci-median {
  position: absolute;
  width: 3px;
  height: 100%;
  background: #2060c0;
  border-radius: 1px;
}
.ci-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.75rem;
  color: #888;
}

/* Incident browser */
.filters { margin: 0.5rem 0; display: flex; gap: 0.25rem; flex-wrap: wrap; }
.filters button {
  padding: 0.25rem 0.75rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
  font-size: 0.85rem;
}
.filters button.active { background: #2060c0; color: #fff; border-color: #2060c0; }
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
  margin-top: 0.5rem;
}
th, td { padding: 0.35rem 0.5rem; text-align: left; border-bottom: 1px solid #e0e0e0; }
th { background: #f5f5f5; position: sticky; top: 0; }
tr:hover { background: #f8f8ff; }
.narrative-cell {
  max-width: 300px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  cursor: pointer;
}
.narrative-cell.expanded { white-space: normal; }
.cbi { color: #999; font-style: italic; }
.incident-count { font-size: 0.9rem; color: #666; margin: 0.25rem 0; }
</style>
</head>
<body>

<h1>Tesla vs Waymo vs Zoox vs Humans</h1>

<div id="estimator"></div>

<!-- TODO human to vet section heading — "Incident browser" -->
<h2>Incident browser</h2>
<div class="filters" id="filters"></div>
<div class="incident-count" id="incident-count"></div>
<div style="overflow-x: auto;">
  <table>
    <thead>
      <tr>
        <!-- TODO human to vet column headers — "Company", "Date", "Location", "Crash with", "Speed (mph)", "Severity", "Narrative" -->
        <th>Company</th>
        <th>Date</th>
        <th>Location</th>
        <th>Crash with</th>
        <th>Speed (mph)</th>
        <th>Severity</th>
        <th>Narrative</th>
      </tr>
    </thead>
    <tbody id="incidents-body"></tbody>
  </table>
</div>

<script>
"use strict";

function fail(msg, details) {
  const suffix = details === undefined ? "" : " " + JSON.stringify(details);
  throw new Error(msg + suffix);
}

function must(cond, msg, details) {
  cond || fail(msg, details);
}

function byId(id) {
  const node = document.getElementById(id);
  must(node !== null, "Missing required DOM node", {id});
  return node;
}

// --- Gamma distribution math ---

// Log-gamma via Lanczos approximation (g=7, n=9)
const LANCZOS_C = [
  0.99999999999980993, 676.5203681218851, -1259.1392167224028,
  771.32342877765313, -176.61502916214059, 12.507343278686905,
  -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7
];
function lgamma(x) {
  if (x < 0.5) return Math.log(Math.PI / Math.sin(Math.PI * x)) - lgamma(1 - x);
  x -= 1;
  let a = LANCZOS_C[0];
  const t = x + 7.5; // g + 0.5
  for (let i = 1; i < 9; i++) a += LANCZOS_C[i] / (x + i);
  return 0.5 * Math.log(2 * Math.PI) + (x + 0.5) * Math.log(t) - t + Math.log(a);
}

// Lower regularized incomplete gamma function P(a, x)
// Series expansion for x < a + 1, continued fraction otherwise
function gammainc(a, x) {
  if (x < 0) return 0;
  if (x === 0) return 0;
  if (x < a + 1) {
    // Series: P(a,x) = e^{-x} x^a sum_{n=0}^{inf} x^n / Gamma(a+n+1)
    let sum = 1 / a;
    let term = 1 / a;
    for (let n = 1; n < 200; n++) {
      term *= x / (a + n);
      sum += term;
      if (Math.abs(term) < Math.abs(sum) * 1e-14) break;
    }
    return sum * Math.exp(-x + a * Math.log(x) - lgamma(a));
  }
  // Continued fraction for upper gamma Q(a,x) = 1 - P(a,x)
  // Using modified Lentz's method
  let f = x - a + 1;
  if (Math.abs(f) < 1e-30) f = 1e-30;
  let c = f;
  let d = 0;
  for (let n = 1; n < 200; n++) {
    const an = n * (a - n);
    const bn = x - a + 1 + 2 * n;
    d = bn + an * d;
    if (Math.abs(d) < 1e-30) d = 1e-30;
    c = bn + an / c;
    if (Math.abs(c) < 1e-30) c = 1e-30;
    d = 1 / d;
    const delta = c * d;
    f *= delta;
    if (Math.abs(delta - 1) < 1e-14) break;
  }
  const q = Math.exp(-x + a * Math.log(x) - lgamma(a)) / f;
  return 1 - q;
}

// Gamma quantile: find x such that P(a, x*b) = p, where Gamma(a, b) has rate b
// Returns x (the quantile of Gamma(shape=a, rate=b))
function gammaquant(a, b, p) {
  must(a > 0 && b > 0 && p > 0 && p < 1,
    "gammaquant: invalid params", {a, b, p});
  // Initial guess via Wilson-Hilferty approximation on chi-squared
  const nu = 2 * a;
  // Normal quantile approximation (Abramowitz & Stegun 26.2.23)
  const t = p < 0.5 ? p : 1 - p;
  const s = Math.sqrt(-2 * Math.log(t));
  let zabs = s - (2.515517 + 0.802853*s + 0.010328*s*s) /
                   (1 + 1.432788*s + 0.189269*s*s + 0.001308*s*s*s);
  const z = p < 0.5 ? -zabs : zabs;
  // Wilson-Hilferty
  const wh = 1 - 2/(9*nu) + z * Math.sqrt(2/(9*nu));
  let x = (nu / 2) * Math.max(wh * wh * wh, 0.001) / b;
  // Newton's method to refine
  for (let i = 0; i < 50; i++) {
    const cdf = gammainc(a, x * b);
    const err = cdf - p;
    if (Math.abs(err) < 1e-12) break;
    // PDF of Gamma(a, b): b^a x^{a-1} e^{-bx} / Gamma(a)
    const logpdf = a * Math.log(b) + (a-1) * Math.log(x) - b*x - lgamma(a);
    const pdf = Math.exp(logpdf);
    if (pdf < 1e-100) break; // avoid division by ~0
    const step = err / pdf;
    x = Math.max(x - step, x / 10); // don't go negative or overshoot
  }
  return x;
}

// Compute miles-per-incident estimate with 90% credible interval
// k = incident count, m = miles driven
function estimateRate(k, m) {
  const a = k + 0.5; // posterior shape (Jeffreys prior)
  const b = m;        // posterior rate
  const tail = (1 - CI_MASS) / 2;
  // Median of 1/lambda = 1 / median(lambda)
  const medianLambda = gammaquant(a, b, 0.5);
  const loLambda     = gammaquant(a, b, 1 - tail);
  const hiLambda     = gammaquant(a, b, tail);
  return {
    median: 1 / medianLambda,
    lo:     1 / loLambda,   // lower bound of miles-per-incident
    hi:     1 / hiLambda,   // upper bound of miles-per-incident
  };
}

// --- Data and UI ---

let incidents = [];
const CI_MASS = 0.8;
const COMPANY_COLORS = {
  Tesla: "#d13b2d",
  Waymo: "#2a8f57",
  Zoox: "#b7771a",
};
// Tesla pre-Sep-1 miles (all empty driver's seat)
const TESLA_PRE_SEP_MILES = 93849;

function pct(v) {
  return v / 100;
}

function deadheadMultiplier(deadheadPct) {
  const deadheadFrac = pct(deadheadPct);
  must(deadheadFrac >= 0 && deadheadFrac < 1,
    "deadhead share out of range", {deadheadPct});
  return 1 / (1 - deadheadFrac);
}

function factorizedParts(baseMiles, deadheadPct, nonePct, scopePct) {
  const baseNoneMiles = baseMiles * pct(nonePct);
  const mDeadhead = deadheadMultiplier(deadheadPct);
  return {
    baseMiles,
    baseNoneMiles,
    deadheadPct,
    nonePct,
    scopePct,
    deadheadMultiplier: mDeadhead,
    miles: baseNoneMiles * mDeadhead * pct(scopePct),
  };
}

// Company configs: incident count from data, slider definitions
const COMPANIES = {
  Tesla: {
    sliders: [
      {
        id: "tesla-miles",
        // TODO human to vet label — "Total robotaxi miles"
        // TO-DO human to vet tooltip text.
        label: "Total robotaxi miles",
        tip: "Base robotaxi miles in this window before applying scope and non-service factors.",
        min: 400000, max: 650000, step: 10000, value: 500000,
        fmt: v => v.toLocaleString(),
      },
      {
        id: "tesla-frac",
        // TODO human to vet label — "% post-Sep-1 without driver"
        // TO-DO human to vet tooltip text.
        label: "% post-Sep-1 without driver",
        tip: "Share of post-Sep-1 miles where the driver seat is empty.",
        min: 0, max: 100, step: 1, value: 70,
        fmt: v => v + "%",
      },
      {
        id: "tesla-deadhead",
        // TO-DO human to vet label — "Non-service share (deadhead)"
        // TO-DO human to vet tooltip text.
        label: "Non-service share",
        tip: "Share of ADS miles with no passenger in the car; used for the non-service multiplier.",
        min: 0, max: 40, step: 1, value: 20,
        fmt: v => v + "%",
      },
      {
        id: "tesla-scope",
        // TO-DO human to vet label — "Scope fraction (US/public/ADS)"
        // TO-DO human to vet tooltip text.
        label: "Scope fraction (US/public/ADS)",
        tip: "Fraction remaining after filtering to US public-road ADS-engaged miles.",
        min: 90, max: 100, step: 1, value: 100,
        fmt: v => v + "%",
      },
    ],
    getParts: vals => {
      const baseMiles = vals["tesla-miles"];
      must(baseMiles >= TESLA_PRE_SEP_MILES,
        "tesla base miles below pre-Sep-1 miles", {baseMiles});
      const nonePostPct = vals["tesla-frac"];
      const postSepMiles = baseMiles - TESLA_PRE_SEP_MILES;
      const baseNoneMiles = TESLA_PRE_SEP_MILES + pct(nonePostPct) * postSepMiles;
      const deadheadPct = vals["tesla-deadhead"];
      const scopePct = vals["tesla-scope"];
      const mDeadhead = deadheadMultiplier(deadheadPct);
      return {
        baseMiles,
        baseNoneMiles,
        deadheadPct,
        nonePct: nonePostPct,
        scopePct,
        deadheadMultiplier: mDeadhead,
        miles: baseNoneMiles * mDeadhead * pct(scopePct),
      };
    },
  },
  Waymo: {
    sliders: [
      {
        id: "waymo-miles",
        // TODO human to vet label — "Driverless miles"
        // TO-DO human to vet tooltip text.
        label: "Driverless miles",
        tip: "Waymo base miles in this window before additional factors.",
        min: 35000000, max: 65000000, step: 1000000, value: 43000000,
        fmt: v => (v / 1e6).toFixed(0) + "M",
      },
      {
        id: "waymo-deadhead",
        // TO-DO human to vet label — "Non-service share (deadhead)"
        // TO-DO human to vet tooltip text.
        label: "Non-service share",
        tip: "Share of miles without a passenger; fixed at zero here because base miles are treated as total miles.",
        min: 0, max: 0, step: 1, value: 0,
        fmt: v => v + "%",
      },
      {
        id: "waymo-none",
        // TO-DO human to vet label — "Operator=none fraction"
        // TO-DO human to vet tooltip text.
        label: "Operator=none fraction",
        tip: "Fraction of miles corresponding to Driver/Operator Type = None.",
        min: 100, max: 100, step: 1, value: 100,
        fmt: v => v + "%",
      },
      {
        id: "waymo-scope",
        // TO-DO human to vet label — "Scope fraction (US/public/ADS)"
        // TO-DO human to vet tooltip text.
        label: "Scope fraction (US/public/ADS)",
        tip: "Fraction remaining after filtering to US public-road ADS-engaged miles.",
        min: 99, max: 100, step: 1, value: 100,
        fmt: v => v + "%",
      },
    ],
    getParts: vals => factorizedParts(
      vals["waymo-miles"],
      vals["waymo-deadhead"],
      vals["waymo-none"],
      vals["waymo-scope"],
    ),
  },
  Zoox: {
    sliders: [
      {
        id: "zoox-miles",
        // TODO human to vet label — "Driverless miles"
        // TO-DO human to vet tooltip text.
        label: "Driverless miles",
        tip: "Zoox base miles in this window before non-service and scope factors.",
        min: 150000, max: 700000, step: 25000, value: 300000,
        fmt: v => v.toLocaleString(),
      },
      {
        id: "zoox-deadhead",
        // TO-DO human to vet label — "Non-service share (deadhead)"
        // TO-DO human to vet tooltip text.
        label: "Non-service share",
        tip: "Share of ADS miles with no passenger; converts service miles to total VMT.",
        min: 0, max: 40, step: 1, value: 20,
        fmt: v => v + "%",
      },
      {
        id: "zoox-none",
        // TO-DO human to vet label — "Operator=none fraction"
        // TO-DO human to vet tooltip text.
        label: "Operator=none fraction",
        tip: "Fraction of ADS miles with no in-vehicle operator under the SGO definition.",
        min: 70, max: 100, step: 1, value: 100,
        fmt: v => v + "%",
      },
      {
        id: "zoox-scope",
        // TO-DO human to vet label — "Scope fraction (US/public/ADS)"
        // TO-DO human to vet tooltip text.
        label: "Scope fraction (US/public/ADS)",
        tip: "Fraction remaining after exclusions outside US, outside public roads, or outside ADS-engaged miles.",
        min: 90, max: 100, step: 1, value: 100,
        fmt: v => v + "%",
      },
    ],
    getParts: vals => factorizedParts(
      vals["zoox-miles"],
      vals["zoox-deadhead"],
      vals["zoox-none"],
      vals["zoox-scope"],
    ),
  },
};

// Count incidents per company from loaded data
function countByCompany() {
  const counts = {};
  for (const inc of incidents) {
    counts[inc.company] = (counts[inc.company] || 0) + 1;
  }
  return counts;
}

function denominatorBounds(cfg) {
  let corners = [{}];
  for (const s of cfg.sliders) {
    const next = [];
    for (const corner of corners) {
      next.push({...corner, [s.id]: s.min});
      next.push({...corner, [s.id]: s.max});
    }
    corners = next;
  }
  const denoms = corners.map(vals => cfg.getParts(vals).miles);
  return {
    min: Math.min(...denoms),
    max: Math.max(...denoms),
  };
}

function scaleLinear(v, d0, d1, r0, r1) {
  const span = (d1 - d0) || 1;
  return r0 + (v - d0) * (r1 - r0) / span;
}

function sampledEstimates(k, xMin, xMax, n) {
  const out = [];
  for (let i = 0; i <= n; i++) {
    const x = xMin + (xMax - xMin) * i / n;
    out.push({x, est: estimateRate(k, x)});
  }
  return out;
}

function medianPath(samples, mapX, mapY) {
  let d = "";
  for (let i = 0; i < samples.length; i++) {
    const s = samples[i];
    d += `${i ? " L " : "M "}${mapX(s.x).toFixed(2)} ${mapY(s.est.median).toFixed(2)}`;
  }
  return d;
}

function bandPath(samples, mapX, mapY) {
  let d = "";
  for (let i = 0; i < samples.length; i++) {
    const s = samples[i];
    d += `${i ? " L " : "M "}${mapX(s.x).toFixed(2)} ${mapY(s.est.hi).toFixed(2)}`;
  }
  for (let i = samples.length - 1; i >= 0; i--) {
    const s = samples[i];
    d += ` L ${mapX(s.x).toFixed(2)} ${mapY(s.est.lo).toFixed(2)}`;
  }
  return d + " Z";
}

function sliderVals(cfg) {
  const vals = {};
  for (const s of cfg.sliders) vals[s.id] = Number(byId(s.id).value);
  return vals;
}

function companySummaries(counts) {
  return Object.keys(COMPANIES).map(company => {
    const cfg = COMPANIES[company];
    const vals = sliderVals(cfg);
    const miles = cfg.getParts(vals).miles;
    const k = counts[company] || 0;
    return {company, k, miles, est: estimateRate(k, miles)};
  });
}

function updateAllEstimates() {
  for (const company of Object.keys(COMPANIES)) updateEstimate(company);
}

function buildEstimator() {
  const container = byId("estimator");
  container.replaceChildren();
  const counts = countByCompany();

  for (const [company, cfg] of Object.entries(COMPANIES)) {
    const k = counts[company] || 0;
    const panel = document.createElement("div");
    panel.className = "company-panel";
    panel.dataset.company = company;

    // TODO human to vet — "incidents"
    let html = `<h3 id="header-stats-${company}">${company}: ${k} incidents in 0 miles ⇒ ? miles per incident</h3>`;

    for (const s of cfg.sliders) {
      must(typeof s.tip === "string" && s.tip.length > 0,
        "slider missing tooltip", {company, sliderId: s.id});
      const tip = escAttr(s.tip);
      html += `
        <div class="slider-row">
          <label for="${s.id}" title="${tip}">${s.label}</label>
          <input type="range" id="${s.id}" min="${s.min}" max="${s.max}"
                 step="${s.step}" value="${s.value}" title="${tip}">
          <span class="val" id="${s.id}-val">${s.fmt(s.value)}</span>
        </div>`;
    }

    html += `<div class="result-box" id="result-${company}"></div>`;
    panel.innerHTML = html;
    container.appendChild(panel);

    // Attach slider listeners
    for (const s of cfg.sliders) {
      const input = byId(s.id);
      const valSpan = byId(s.id + "-val");
      input.addEventListener("input", () => {
        valSpan.textContent = s.fmt(Number(input.value));
        updateAllEstimates();
      });
    }
  }
  updateAllEstimates();
}

function updateEstimate(company) {
  const cfg = COMPANIES[company];
  must(cfg !== undefined, "Unknown company config", {company});
  const counts = countByCompany();
  const summaries = companySummaries(counts);
  const thisSummary = summaries.find(s => s.company === company);
  must(thisSummary !== undefined, "Missing summary for company", {company});
  const peers = summaries.filter(s => s.company !== company);
  const k = thisSummary.k;
  const miles = thisSummary.miles;
  const est = thisSummary.est;
  byId("header-stats-" + company).textContent =
    `${company}: ${k} incidents in ${Math.round(miles).toLocaleString()} miles ⇒ ${fmtMiles(est.median)} miles per incident`;

  const box = byId("result-" + company);
  const bounds = denominatorBounds(cfg);
  const xMin = bounds.min;
  const xMax = bounds.max;
  const samples = sampledEstimates(k, xMin, xMax, 40);
  const yMin = Math.min(...samples.map(s => s.est.lo), ...peers.map(p => p.est.median));
  const yMax = Math.max(...samples.map(s => s.est.hi), ...peers.map(p => p.est.median));
  const svgW = 520;
  const svgH = 220;
  const mLeft = 56;
  const mRight = 12;
  const mTop = 10;
  const mBot = 40;
  const pW = svgW - mLeft - mRight;
  const pH = svgH - mTop - mBot;
  const mapX = x => scaleLinear(x, xMin, xMax, mLeft, mLeft + pW);
  const mapY = y => scaleLinear(y, yMin, yMax, mTop + pH, mTop);
  const pointX = mapX(miles);
  const pointY = mapY(est.median);
  const xTicks = [xMin, (xMin + xMax) / 2, xMax];
  const yTicks = [yMin, (yMin + yMax) / 2, yMax];
  const band = bandPath(samples, mapX, mapY);
  const path = medianPath(samples, mapX, mapY);

  // TODO human to vet — "X miles between incidents",
  //   "90% credible interval: lo – hi", "Effective miles: N · Incidents: K"
  // TO-DO human to vet denominator component copy.
  // TO-DO human to vet graph axis copy.
  box.innerHTML = `
    <svg class="graph-svg" viewBox="0 0 ${svgW} ${svgH}">
      ${xTicks.map(x => `
        <line class="graph-grid" x1="${mapX(x)}" y1="${mTop}" x2="${mapX(x)}" y2="${mTop + pH}"></line>
        <text class="graph-tick" x="${mapX(x)}" y="${svgH - 16}" text-anchor="middle">${Math.round(x).toLocaleString()}</text>
      `).join("")}
      ${yTicks.map(y => `
        <line class="graph-grid" x1="${mLeft}" y1="${mapY(y)}" x2="${mLeft + pW}" y2="${mapY(y)}"></line>
        <text class="graph-tick" x="${mLeft - 8}" y="${mapY(y) + 4}" text-anchor="end">${fmtMiles(y)}</text>
      `).join("")}
      <line class="graph-axis" x1="${mLeft}" y1="${mTop}" x2="${mLeft}" y2="${mTop + pH}"></line>
      <line class="graph-axis" x1="${mLeft}" y1="${mTop + pH}" x2="${mLeft + pW}" y2="${mTop + pH}"></line>
      <path class="graph-band" d="${band}"></path>
      <path class="graph-line" d="${path}"></path>
      ${peers.map(p => `
        <line class="graph-refline" x1="${mLeft}" y1="${mapY(p.est.median)}" x2="${mLeft + pW}" y2="${mapY(p.est.median)}" style="stroke:${COMPANY_COLORS[p.company]}"></line>
        <text class="graph-reflabel" x="${mLeft + pW - 4}" y="${mapY(p.est.median) - 4}" text-anchor="end" style="fill:${COMPANY_COLORS[p.company]}">${p.company}: ${fmtMiles(p.est.median)}</text>
      `).join("")}
      <circle class="graph-point" cx="${pointX}" cy="${pointY}" r="5"></circle>
      <text class="graph-label" x="${mLeft + pW / 2}" y="${svgH - 2}" text-anchor="middle">Total Autonomous Miles</text>
      <text class="graph-label" x="12" y="${mTop + pH / 2}" transform="rotate(-90 12 ${mTop + pH / 2})" text-anchor="middle">Miles per incident</text>
    </svg>
  `;
}

function fmtMiles(n) {
  if (n >= 1e6) return (n / 1e6).toFixed(1) + "M";
  if (n >= 1e3) return (n / 1e3).toFixed(1) + "K";
  return Math.round(n).toLocaleString();
}

// --- Incident Browser ---

let activeFilter = "All";

function buildBrowser() {
  const counts = countByCompany();
  const filterDiv = byId("filters");
  filterDiv.replaceChildren();
  // TODO human to vet button labels — "All", "Tesla", "Waymo", "Zoox" (these are just company names + "All")
  const companies = ["All", ...Object.keys(COMPANIES)];
  for (const c of companies) {
    const btn = document.createElement("button");
    const n = c === "All" ? incidents.length : (counts[c] || 0);
    btn.textContent = `${c} (${n})`;
    btn.className = c === activeFilter ? "active" : "";
    btn.addEventListener("click", () => {
      activeFilter = c;
      buildBrowser();
    });
    filterDiv.appendChild(btn);
  }
  renderTable();
}

function renderTable() {
  const tbody = byId("incidents-body");
  const filtered = activeFilter === "All"
    ? incidents
    : incidents.filter(r => r.company === activeFilter);

  byId("incident-count").textContent =
    `${filtered.length} incidents`; // TODO human to vet — "N incidents"

  tbody.innerHTML = "";
  for (const r of filtered) {
    const tr = document.createElement("tr");
    const isCbi = r.narrativeCbi === "Y";
    const narrativeText = isCbi
      // TO-DO human to vet acronym expansion copy.
      ? "[\"Confidential Business Information\"]"
      : (r.narrative || "");
    const narrativeClass = isCbi ? "narrative-cell cbi" : "narrative-cell";

    tr.innerHTML = `
      <td>${escHtml(r.company)}</td>
      <td>${escHtml(r.date)}</td>
      <td>${escHtml(r.city)}, ${escHtml(r.state)}</td>
      <td>${escHtml(r.crashWith)}</td>
      <td>${escHtml(r.speed !== null ? String(r.speed) : "?")}</td>
      <td>${escHtml(shortenSeverity(r.severity))}</td>
      <td class="${narrativeClass}">${escHtml(narrativeText)}</td>
    `;
    // Click to expand/collapse narrative
    const narrativeTd = tr.querySelector(".narrative-cell");
    must(narrativeTd !== null, "Missing narrative cell");
    narrativeTd.addEventListener("click", () => {
      narrativeTd.classList.toggle("expanded");
    });
    tbody.appendChild(tr);
  }
}

function shortenSeverity(s) {
  const rules = [
    ["No Injured", "No injury"],
    ["Minor W/O", "Minor injury"],
    ["Minor W/", "Minor injury (hosp.)"],
    ["Serious", "Serious"],
    ["Fatal", "Fatal"],
    ["Property", "Property only"],
  ];
  const hit = (s || "") && rules.find(([needle]) => s.includes(needle));
  return hit ? hit[1] : (s || "?");
}

function escHtml(s) {
  const d = document.createElement("div");
  d.textContent = s;
  return d.innerHTML;
}

function escAttr(s) {
  return escHtml(s).replace(/"/g, "&quot;");
}

// --- Init ---

fetch("incidents.json")
  .then(r => (must(r.ok, "Failed to load incidents.json", {status: r.status}), r.json()))
  .then(data => {
    must(Array.isArray(data), "incidents.json must be an array");
    for (const inc of data) {
      must(inc !== null && typeof inc === "object", "incident must be an object");
      must(typeof inc.company === "string", "incident missing company");
      must(COMPANIES[inc.company] !== undefined,
        "incidents.json has unknown company", {company: inc.company});
    }
    incidents = data;
    buildEstimator();
    buildBrowser();
  });
</script>
</body>
</html>
