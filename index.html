<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Crashla</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: system-ui, -apple-system, sans-serif;
  line-height: 1.5;
  color: #1a1a1a;
  max-width: 960px;
  margin: 0 auto;
  padding: 1rem;
}
h1 { margin-bottom: 0.5rem; }
h2 { margin: 1.5rem 0 0.75rem; border-bottom: 2px solid #e0e0e0; padding-bottom: 0.25rem; }
h3 { margin: 0.75rem 0 0.5rem; }

/* Rate estimator */
.company-panel {
  border: 1px solid #d0d0d0;
  border-radius: 6px;
  padding: 1rem;
  margin-bottom: 1rem;
  background: #fafafa;
}
.company-panel h3 { margin-top: 0; }
.slider-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin: 0.5rem 0;
}
.slider-row label { min-width: 220px; font-size: 0.9rem; }
.slider-row input[type="range"] { flex: 1; min-width: 120px; }
.slider-row .val { min-width: 100px; text-align: right; font-variant-numeric: tabular-nums; }
.result-box {
  margin-top: 0.75rem;
  padding: 0.75rem;
  background: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  font-variant-numeric: tabular-nums;
}
.result-box .estimate {
  font-size: 1.25rem;
  font-weight: 600;
}
.result-box .ci { font-size: 0.9rem; color: #555; }
.graph-svg {
  width: 100%;
  height: auto;
  display: block;
}
.graph-grid {
  display: none;
}
.graph-axis {
  stroke: #a7afbf;
  stroke-width: 1;
}
.graph-line {
  fill: none;
  stroke: #2060c0;
  stroke-width: 2;
}
.graph-band {
  fill: rgba(32, 96, 192, 0.18);
}
.graph-point {
  fill: #d13b2d;
  stroke: #fff;
  stroke-width: 2;
}
.graph-refline {
  stroke-width: 1.5;
  stroke-dasharray: 6 4;
}
.graph-reflabel {
  font-size: 10px;
  font-weight: 600;
  paint-order: stroke;
  stroke: #fff;
  stroke-width: 3px;
}
.graph-tick {
  fill: #5b6475;
  font-size: 9px;
}
.graph-label {
  fill: #334;
  font-size: 11px;
}
.ci-bar-container {
  position: relative;
  height: 28px;
  margin: 0.5rem 0;
  background: #f0f0f0;
  border-radius: 4px;
  overflow: hidden;
}
.ci-bar {
  position: absolute;
  height: 100%;
  background: #b0d0ff;
  border-radius: 4px;
}
.ci-median {
  position: absolute;
  width: 3px;
  height: 100%;
  background: #2060c0;
  border-radius: 1px;
}
.ci-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.75rem;
  color: #888;
}

/* Incident browser */
.filters { margin: 0.5rem 0; display: flex; gap: 0.25rem; flex-wrap: wrap; }
.filters button {
  padding: 0.25rem 0.75rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
  font-size: 0.85rem;
}
.filters button.active { background: #2060c0; color: #fff; border-color: #2060c0; }
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
  margin-top: 0.5rem;
}
th, td { padding: 0.35rem 0.5rem; text-align: left; border-bottom: 1px solid #e0e0e0; }
th { background: #f5f5f5; position: sticky; top: 0; cursor: pointer; user-select: none; }
th:hover { background: #e8e8e8; }
th .sort-arrow { font-size: 0.7em; margin-left: 0.2em; }
tr:hover { background: #f8f8ff; }
.narrative-cell {
  max-width: 300px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  cursor: pointer;
}
.narrative-cell.expanded { white-space: normal; }
.cbi { color: #999; font-style: italic; }
.incident-count { font-size: 0.9rem; color: #666; margin: 0.25rem 0; }
.fault-cell {
  font-variant-numeric: tabular-nums;
  text-align: center;
  white-space: nowrap;
  cursor: help;
}
.fault-bar {
  display: inline-block;
  height: 14px;
  border-radius: 2px;
  vertical-align: middle;
  margin-right: 4px;
}
.weight-panel {
  margin: 0.5rem 0;
  padding: 0.75rem;
  background: #fafafa;
  border: 1px solid #d0d0d0;
  border-radius: 6px;
  font-size: 0.85rem;
}
.weight-panel h4 { margin: 0 0 0.4rem; font-size: 0.9rem; }
.weight-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin: 0.3rem 0;
}
.weight-row label { min-width: 70px; }
.weight-row input[type="range"] { flex: 1; min-width: 80px; }
.weight-row .val { min-width: 30px; text-align: right; font-variant-numeric: tabular-nums; }

/* Monthly views */
.month-panel {
  border: 1px solid #d0d0d0;
  border-radius: 6px;
  padding: 1rem;
  margin-bottom: 1rem;
  background: #fafafa;
}
.month-note {
  font-size: 0.9rem;
  color: #5b6475;
  margin-bottom: 0.6rem;
}
.month-chart {
  margin-bottom: 0.8rem;
}
.month-chart h3 {
  margin: 0 0 0.35rem;
}
.month-company-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 0.9rem;
}
.month-svg {
  width: 100%;
  height: auto;
  display: block;
  background: #fff;
  border: 1px solid #dfe4ef;
  border-radius: 4px;
}
.month-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 0.7rem;
  margin-top: 0.3rem;
  font-size: 0.82rem;
}
.month-legend-item {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
}
.month-chip {
  width: 12px;
  height: 12px;
  border-radius: 3px;
  border: 1px solid rgba(0, 0, 0, 0.18);
  display: inline-block;
}
.month-grid {
  display: none;
}
.month-axis {
  stroke: #95a0b8;
  stroke-width: 1;
}
.month-axis-right {
  stroke: #95a0b8;
  stroke-width: 1;
}
.month-vmt-line {
  fill: none;
  stroke-width: 2;
}
.month-mpi-all-line {
  fill: none;
  stroke-width: 2;
}
.month-inc-count {
  fill: #131313;
  font-size: 9px;
  font-weight: 600;
  text-anchor: middle;
  dominant-baseline: middle;
  paint-order: stroke;
  stroke: #fff;
  stroke-width: 2px;
}
.month-inc-total {
  fill: #131313;
  font-size: 10px;
  font-weight: 700;
  text-anchor: middle;
  dominant-baseline: middle;
}
.month-dot {
  stroke: #fff;
  stroke-width: 1.5;
}
.month-linekey {
  width: 22px;
  height: 0;
  border-top: 2px solid #4a5264;
  display: inline-block;
}
.month-linekey.solid {
  border-top-style: solid;
}
.month-linekey.dashed {
  border-top-style: dashed;
}
.month-err {
  stroke-width: 1.4;
  opacity: 0.9;
}
.month-tick {
  fill: #5b6475;
  font-size: 10px;
}
.month-label {
  fill: #334;
  font-size: 11px;
}
.month-summary {
  margin-top: 0.75rem;
  background: #fff;
  border: 1px solid #dfe4ef;
  border-radius: 4px;
  padding: 0.7rem;
}
.month-summary-title {
  font-size: 0.9rem;
  font-weight: 600;
  margin-bottom: 0.4rem;
}
.month-summary table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.82rem;
}
.month-summary th,
.month-summary td {
  padding: 0.28rem 0.42rem;
  border-bottom: 1px solid #e8ecf5;
  text-align: right;
}
.month-summary th:first-child,
.month-summary td:first-child {
  text-align: left;
}
</style>
</head>
<body>

<h1>Tesla vs Waymo vs Zoox vs Humans</h1>

<!-- TO-DO: Human vet all new end-user copy in this section. -->
<div class="month-panel">
  <div id="chart-mpi-all" class="month-chart"></div>
  <div class="month-legend" id="month-legend-mpi-companies"></div>
  <div class="month-legend" id="month-legend-mpi-lines"></div>
  <div id="chart-company-series" class="month-company-grid"></div>
  <div class="month-legend" id="month-legend-lines"></div>
  <div class="month-legend" id="month-legend-speed"></div>
  <div id="month-summary-box" class="month-summary"></div>
</div>

<div class="company-panel">
  <div class="slider-row">
    <label for="ci-mass"
title="The higher this is, the wider the confidence intervals">Confidence intervals</label>
    <input type="range" id="ci-mass" min="50" max="99.9" step="0.1" value="95"
title="The higher this is, the wider the confidence intervals">
    <span class="val" id="ci-mass-val">95.0%</span>
  </div>
</div>

<div id="estimator"></div>

<h2>Incident browser</h2>
<div class="filters" id="filters"></div>
<div class="weight-panel">
  <h4>Fault estimate weights</h4>
  <div class="weight-row">
    <label for="w-claude">Claude</label>
    <input type="range" id="w-claude" min="0" max="10" step="1" value="3">
    <span class="val" id="w-claude-val">3</span>
  </div>
  <div class="weight-row">
    <label for="w-codex">Codex</label>
    <input type="range" id="w-codex" min="0" max="10" step="1" value="3">
    <span class="val" id="w-codex-val">3</span>
  </div>
  <div class="weight-row">
    <label for="w-gemini">Gemini</label>
    <input type="range" id="w-gemini" min="0" max="10" step="1" value="3">
    <span class="val" id="w-gemini-val">3</span>
  </div>
</div>
<div class="incident-count" id="incident-count"></div>
<div style="overflow-x: auto;">
  <table>
    <thead id="incidents-head">
      <tr>
        <th>Company</th>
        <th>Date</th>
        <th>Location</th>
        <th>Crash with</th>
        <th>Speed (mph)</th>
        <th>Fault</th>
        <th>Severity</th>
        <th>Narrative</th>
      </tr>
    </thead>
    <tbody id="incidents-body"></tbody>
  </table>
</div>

<script>
"use strict";

function fail(msg, details) {
  const suffix = details === undefined ? "" : " " + JSON.stringify(details);
  throw new Error(msg + suffix);
}

function must(cond, msg, details) {
  cond || fail(msg, details);
}

function byId(id) {
  const node = document.getElementById(id);
  must(node !== null, "Missing required DOM node", {id});
  return node;
}

// --- Gamma distribution math ---

// Log-gamma via Lanczos approximation (g=7, n=9)
const LANCZOS_C = [
  0.99999999999980993, 676.5203681218851, -1259.1392167224028,
  771.32342877765313, -176.61502916214059, 12.507343278686905,
  -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7
];
function lgamma(x) {
  if (x < 0.5) return Math.log(Math.PI / Math.sin(Math.PI * x)) - lgamma(1 - x);
  x -= 1;
  let a = LANCZOS_C[0];
  const t = x + 7.5; // g + 0.5
  for (let i = 1; i < 9; i++) a += LANCZOS_C[i] / (x + i);
  return 0.5 * Math.log(2 * Math.PI) + (x + 0.5) * Math.log(t) - t + Math.log(a);
}

// Lower regularized incomplete gamma function P(a, x)
// Series expansion for x < a + 1, continued fraction otherwise
function gammainc(a, x) {
  if (x < 0) return 0;
  if (x === 0) return 0;
  if (x < a + 1) {
    // Series: P(a,x) = e^{-x} x^a sum_{n=0}^{inf} x^n / Gamma(a+n+1)
    let sum = 1 / a;
    let term = 1 / a;
    for (let n = 1; n < 200; n++) {
      term *= x / (a + n);
      sum += term;
      if (Math.abs(term) < Math.abs(sum) * 1e-14) break;
    }
    return sum * Math.exp(-x + a * Math.log(x) - lgamma(a));
  }
  // Continued fraction for upper gamma Q(a,x) = 1 - P(a,x)
  // Using modified Lentz's method
  let f = x - a + 1;
  if (Math.abs(f) < 1e-30) f = 1e-30;
  let c = f;
  let d = 0;
  for (let n = 1; n < 200; n++) {
    const an = n * (a - n);
    const bn = x - a + 1 + 2 * n;
    d = bn + an * d;
    if (Math.abs(d) < 1e-30) d = 1e-30;
    c = bn + an / c;
    if (Math.abs(c) < 1e-30) c = 1e-30;
    d = 1 / d;
    const delta = c * d;
    f *= delta;
    if (Math.abs(delta - 1) < 1e-14) break;
  }
  const q = Math.exp(-x + a * Math.log(x) - lgamma(a)) / f;
  return 1 - q;
}

// Gamma quantile: find x such that P(a, x*b) = p, where Gamma(a, b) has rate b
// Returns x (the quantile of Gamma(shape=a, rate=b))
function gammaquant(a, b, p) {
  must(a > 0 && b > 0 && p > 0 && p < 1,
    "gammaquant: invalid params", {a, b, p});
  // Initial guess via Wilson-Hilferty approximation on chi-squared
  const nu = 2 * a;
  // Normal quantile approximation (Abramowitz & Stegun 26.2.23)
  const t = p < 0.5 ? p : 1 - p;
  const s = Math.sqrt(-2 * Math.log(t));
  let zabs = s - (2.515517 + 0.802853*s + 0.010328*s*s) /
                   (1 + 1.432788*s + 0.189269*s*s + 0.001308*s*s*s);
  const z = p < 0.5 ? -zabs : zabs;
  // Wilson-Hilferty
  const wh = 1 - 2/(9*nu) + z * Math.sqrt(2/(9*nu));
  let x = (nu / 2) * Math.max(wh * wh * wh, 0.001) / b;
  // Newton's method to refine
  for (let i = 0; i < 50; i++) {
    const cdf = gammainc(a, x * b);
    const err = cdf - p;
    if (Math.abs(err) < 1e-12) break;
    // PDF of Gamma(a, b): b^a x^{a-1} e^{-bx} / Gamma(a)
    const logpdf = a * Math.log(b) + (a-1) * Math.log(x) - b*x - lgamma(a);
    const pdf = Math.exp(logpdf);
    if (pdf < 1e-100) break; // avoid division by ~0
    const step = err / pdf;
    x = Math.max(x - step, x / 10); // don't go negative or overshoot
  }
  return x;
}

// Compute miles-per-incident estimate with 90% credible interval
// k = incident count, m = miles driven
function estimateRate(k, m) {
  const a = k + 0.5; // posterior shape (Jeffreys prior)
  const b = m;       // posterior rate
  const tail = (1 - ciMass()) / 2;
  // Median of 1/lambda = 1 / median(lambda)
  const medianLambda = gammaquant(a, b, 0.5);
  const loLambda     = gammaquant(a, b, 1 - tail);
  const hiLambda     = gammaquant(a, b, tail);
  return {
    median: 1 / medianLambda,
    lo:     1 / loLambda,   // lower bound of miles-per-incident
    hi:     1 / hiLambda,   // upper bound of miles-per-incident
  };
}

// --- Data and UI ---

let incidents = [];
let vmtRows = [];
let faultData = {}; // reportId -> {claude, codex, gemini, rclaude, rcodex, rgemini}
const CI_MASS_MIN_PCT = 50;
const CI_MASS_MAX_PCT = 99.9;
const CI_MASS_STEP_PCT = 0.1;
const CI_MASS_DEFAULT_PCT = 95;
const COMPANY_COLORS = {
  Tesla: "#d13b2d",
  Waymo: "#2a8f57",
  Zoox: "#b7771a",
  Humans: "#5b6475",
};
const COMPANY_ORDER = ["Tesla", "Waymo", "Zoox", "Humans"];
const INCIDENT_MODEL_COMPANIES = ["Tesla", "Waymo", "Zoox"];
const AXIS_MIN_DEFAULT_PCT = 0;
const AXIS_MAX_DEFAULT_PCT = 100;
const AXIS_MIN_LABEL = "X-axis min";
const AXIS_MAX_LABEL = "X-axis max";
const AXIS_MIN_TIP = "Lower x-axis bound for this graph.";
const AXIS_MAX_TIP = "Upper x-axis bound for this graph.";
// Tesla pre-Sep-1 miles (all empty driver's seat)
const TESLA_PRE_SEP_MILES = 93849;
const ADS_COMPANIES = ["Tesla", "Waymo", "Zoox"];
const MONTHLY_COMPANY_COLORS = {
  Tesla: "#d13b2d",
  Waymo: "#2060c0",
  Zoox: "#2a8f57",
};
const SPEED_BINS = ["unknown", "31+", "11-30", "1-10", "0"];
const SPEED_LABELS = {
  "31+": "31+ mph",
  "11-30": "11-30 mph",
  "1-10": "1-10 mph",
  unknown: "unknown",
  "0": "0 mph",
};
const SPEED_BIN_COLORS = {
  Tesla: {
    unknown: "#383c46",
    "31+": "#d13b2d",
    "11-30": "#e06f66",
    "1-10": "#efaaa4",
    "0": "#d9d9d9",
  },
  Waymo: {
    unknown: "#383c46",
    "31+": "#2060c0",
    "11-30": "#5a87d1",
    "1-10": "#99b4e5",
    "0": "#d9d9d9",
  },
  Zoox: {
    unknown: "#383c46",
    "31+": "#2a8f57",
    "11-30": "#5ead7e",
    "1-10": "#98ccb0",
    "0": "#d9d9d9",
  },
};
const MONTH_TOKENS = {
  JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6,
  JUL: 7, AUG: 8, SEP: 9, OCT: 10, NOV: 11, DEC: 12,
};
const PARTIAL_MONTH_SCALE = {
  "2025-06": 30 / (30 - 16 + 1),
  "2026-01": 31 / (15 - 1 + 1),
};
const YM_RE = /^(\d{4})-(\d{2})$/;

function pct(v) {
  return v / 100;
}

function ciMassPct() {
  const raw = byId("ci-mass").value;
  const massPct = raw === "" ? CI_MASS_DEFAULT_PCT : Number(raw);
  must(Number.isFinite(massPct), "ci mass percent must be finite", {raw});
  must(massPct >= CI_MASS_MIN_PCT && massPct <= CI_MASS_MAX_PCT,
    "ci mass percent out of range", {massPct});
  return massPct;
}

function ciMass() {
  return ciMassPct() / 100;
}

function renderCiMassValue() {
  byId("ci-mass-val").textContent = ciMassPct().toFixed(1) + "%";
}

function initCiMassControl() {
  const input = byId("ci-mass");
  input.min = String(CI_MASS_MIN_PCT);
  input.max = String(CI_MASS_MAX_PCT);
  input.step = String(CI_MASS_STEP_PCT);
  input.value = String(CI_MASS_DEFAULT_PCT);
  renderCiMassValue();
  input.addEventListener("input", () => {
    renderCiMassValue();
    updateAllEstimates();
  });
}

function deadheadMultiplier(deadheadPct) {
  const deadheadFrac = pct(deadheadPct);
  must(deadheadFrac >= 0 && deadheadFrac < 1,
    "deadhead share out of range", {deadheadPct});
  return 1 / (1 - deadheadFrac);
}

function factorizedParts(baseMiles, deadheadPct) {
  const baseNoneMiles = baseMiles;
  const mDeadhead = deadheadMultiplier(deadheadPct);
  return {
    baseMiles,
    baseNoneMiles,
    deadheadPct,
    deadheadMultiplier: mDeadhead,
    miles: baseNoneMiles * mDeadhead,
  };
}

function scaleEstimate(est, factor) {
  return {
    median: est.median * factor,
    lo: est.lo * factor,
    hi: est.hi * factor,
  };
}

function axisInputId(company, edge) {
  return `x-${edge}-${company}`;
}

function axisValueId(company, edge) {
  return `x-${edge}-${company}-val`;
}

// Company configs: incident count from data, slider definitions
const COMPANIES = {
  Tesla: {
    sliders: [
      {
        id: "tesla-miles",
        label: "Total robotaxi miles",
        tip: "Base robotaxi miles in this window before applying deadhead adjustment.",
        min: 94000, max: 600000, step: 1000, value: 450000,
        fmt: v => v.toLocaleString(),
      },
      {
        id: "tesla-frac",
        label: "% post-Sep-1 without driver",
        tip: "Share of post-Sep-1 miles where the driver seat is empty.",
        min: 0, max: 100, step: 1, value: 70,
        fmt: v => v + "%",
      },
      {
        id: "tesla-deadhead",
        label: "Deadhead fraction",
        tip: "Share of ADS miles with no passenger in the car; used for the deadhead multiplier.",
        min: 0, max: 40, step: 1, value: 20,
        fmt: v => v + "%",
      },
    ],
    getParts: vals => {
      const baseMiles = vals["tesla-miles"];
      must(baseMiles >= TESLA_PRE_SEP_MILES,
        "tesla base miles below pre-Sep-1 miles", {baseMiles});
      const nonePostPct = vals["tesla-frac"];
      const postSepMiles = baseMiles - TESLA_PRE_SEP_MILES;
      const baseNoneMiles = TESLA_PRE_SEP_MILES + pct(nonePostPct) * postSepMiles;
      const deadheadPct = vals["tesla-deadhead"];
      const mDeadhead = deadheadMultiplier(deadheadPct);
      return {
        baseMiles,
        baseNoneMiles,
        deadheadPct,
        deadheadMultiplier: mDeadhead,
        miles: baseNoneMiles * mDeadhead,
      };
    },
  },
  Waymo: {
    sliders: [
      {
        id: "waymo-miles",
        label: "Driverless miles",
        tip: "Waymo base miles in this window before deadhead adjustment.",
        min: 57000000, max: 66000000, step: 1000000, value: 61000000,
        fmt: v => (v / 1e6).toFixed(0) + "M",
      },
      {
        id: "waymo-deadhead",
        label: "Deadhead fraction",
        tip: "Share of ADS miles with no passenger in the car; used for the deadhead multiplier.",
        min: 0, max: 50, step: 1, value: 0,
        fmt: v => v + "%",
      },
    ],
    getParts: vals => factorizedParts(
      vals["waymo-miles"],
      vals["waymo-deadhead"],
    ),
  },
  Zoox: {
    sliders: [
      {
        id: "zoox-miles",
        label: "Driverless miles",
        tip: "Zoox base miles in this window before deadhead adjustment.",
        min: 50000, max: 1000000, step: 25000, value: 300000,
        fmt: v => v.toLocaleString(),
      },
      {
        id: "zoox-deadhead",
        label: "Deadhead fraction",
        tip: "Share of ADS miles with no passenger; converts non-deadhead miles to total Vehicle Miles Traveled (VMT).",
        min: 0, max: 40, step: 1, value: 20,
        fmt: v => v + "%",
      },
    ],
    getParts: vals => factorizedParts(
      vals["zoox-miles"],
      vals["zoox-deadhead"],
    ),
  },
  Humans: {
    sliders: [
      {
        id: "humans-waymo-divisor",
        label: "Humans as 1/x of Waymo miles per incident",
        tip: "Set humans to one-over-x of Waymo miles per incident; range is 1/2 to 1/10.",
        min: 2, max: 10, step: 0.1, value: 5,
        fmt: v => "1/" + Number(v).toFixed(1).replace(/\\.0$/, "") + "x",
      },
    ],
  },
};

// Count incidents per company from loaded data
function countByCompany() {
  const counts = {};
  for (const inc of incidents) {
    counts[inc.company] = (counts[inc.company] || 0) + 1;
  }
  return counts;
}

function primarySliderBounds(cfg, vals) {
  const primary = cfg.sliders[0];
  must(primary !== undefined, "missing primary slider for bounds");
  const loVals = {...vals, [primary.id]: primary.min};
  const hiVals = {...vals, [primary.id]: primary.max};
  const lo = cfg.getParts(loVals).miles;
  const hi = cfg.getParts(hiVals).miles;
  return {
    min: Math.min(lo, hi),
    max: Math.max(lo, hi),
  };
}

function scaleLinear(v, d0, d1, r0, r1) {
  const span = (d1 - d0) || 1;
  return r0 + (v - d0) * (r1 - r0) / span;
}

function sampledEstimates(estAtMiles, xMin, xMax, n) {
  const out = [];
  for (let i = 0; i <= n; i++) {
    const x = xMin + (xMax - xMin) * i / n;
    out.push({x, est: estAtMiles(x)});
  }
  return out;
}

function medianPath(samples, mapX, mapY) {
  let d = "";
  for (let i = 0; i < samples.length; i++) {
    const s = samples[i];
    d += `${i ? " L " : "M "}${mapX(s.x).toFixed(2)} ${mapY(s.est.median).toFixed(2)}`;
  }
  return d;
}

function bandPath(samples, mapX, mapY) {
  let d = "";
  for (let i = 0; i < samples.length; i++) {
    const s = samples[i];
    d += `${i ? " L " : "M "}${mapX(s.x).toFixed(2)} ${mapY(s.est.hi).toFixed(2)}`;
  }
  for (let i = samples.length - 1; i >= 0; i--) {
    const s = samples[i];
    d += ` L ${mapX(s.x).toFixed(2)} ${mapY(s.est.lo).toFixed(2)}`;
  }
  return d + " Z";
}

function layoutRefLabels(peers, mapY, top, height) {
  const minGap = 12;
  const yMin = top + 10;
  const yMax = top + height - 4;
  const laid = peers
    .map(peer => ({
      ...peer,
      lineY: mapY(peer.est.median),
      labelY: 0,
    }))
    .sort((a, b) => a.lineY - b.lineY)
    .map(peer => ({
      ...peer,
      labelY: Math.min(Math.max(peer.lineY - 4, yMin), yMax),
    }));

  for (let pass = 0; pass < 3; pass++) {
    for (let i = 1; i < laid.length; i++) {
      laid[i].labelY = Math.max(laid[i].labelY, laid[i - 1].labelY + minGap);
    }
    for (let i = laid.length - 2; i >= 0; i--) {
      laid[i].labelY = Math.min(laid[i].labelY, laid[i + 1].labelY - minGap);
    }
    for (const peer of laid) {
      peer.labelY = Math.min(Math.max(peer.labelY, yMin), yMax);
    }
  }

  return peers.map(peer => {
    const hit = laid.find(candidate => candidate.company === peer.company);
    must(hit !== undefined, "missing laid-out peer label", {company: peer.company});
    return hit;
  });
}

function axisWindow(company, bounds) {
  const minRaw = byId(axisInputId(company, "min")).value;
  const maxRaw = byId(axisInputId(company, "max")).value;
  const minPct = minRaw === "" ? AXIS_MIN_DEFAULT_PCT : Number(minRaw);
  const maxPct = maxRaw === "" ? AXIS_MAX_DEFAULT_PCT : Number(maxRaw);
  must(Number.isFinite(minPct) && Number.isFinite(maxPct),
    "axis slider values must be finite", {company, minRaw, maxRaw});
  must(minPct >= 0 && minPct <= 99 && maxPct >= 1 && maxPct <= 100,
    "axis slider values out of range", {company, minPct, maxPct});
  must(minPct < maxPct,
    "axis min must be lower than axis max", {company, minPct, maxPct});
  const span = bounds.max - bounds.min;
  return {
    minPct,
    maxPct,
    xMin: bounds.min + span * (minPct / 100),
    xMax: bounds.min + span * (maxPct / 100),
  };
}

function syncAxisSliderBounds(company) {
  const minInput = byId(axisInputId(company, "min"));
  const maxInput = byId(axisInputId(company, "max"));
  const minPct = minInput.value === "" ? AXIS_MIN_DEFAULT_PCT : Number(minInput.value);
  const maxPct = maxInput.value === "" ? AXIS_MAX_DEFAULT_PCT : Number(maxInput.value);
  must(Number.isFinite(minPct) && Number.isFinite(maxPct),
    "axis slider values must be finite", {company, minPct, maxPct});
  must(minPct < maxPct,
    "axis min must be lower than axis max", {company, minPct, maxPct});
  minInput.max = String(maxPct - 1);
  maxInput.min = String(minPct + 1);
}

function sliderVals(cfg) {
  const vals = {};
  for (const s of cfg.sliders) {
    const raw = byId(s.id).value;
    const parsed = raw === "" ? s.value : Number(raw);
    must(Number.isFinite(parsed), "slider value must be finite", {id: s.id, raw});
    vals[s.id] = parsed;
  }
  return vals;
}

function summaryFromIncidentModel(company, counts, valsByCompany) {
  const cfg = COMPANIES[company];
  const vals = valsByCompany[company];
  const miles = cfg.getParts(vals).miles;
  const k = counts[company] || 0;
  const estAtMiles = x => estimateRate(k, x);
  return {
    company,
    k,
    miles,
    est: estAtMiles(miles),
    estAtMiles,
    bounds: primarySliderBounds(cfg, vals),
  };
}

function companySummaries(counts) {
  const valsByCompany = {};
  for (const company of COMPANY_ORDER) {
    valsByCompany[company] = sliderVals(COMPANIES[company]);
  }

  const summaries = {};
  for (const company of INCIDENT_MODEL_COMPANIES) {
    summaries[company] = summaryFromIncidentModel(company, counts, valsByCompany);
  }

  const waymo = summaries.Waymo;
  must(waymo !== undefined, "Humans summary requires Waymo summary");
  const waymoDivisor = valsByCompany.Humans["humans-waymo-divisor"];
  must(waymoDivisor >= 2 && waymoDivisor <= 10,
    "Humans/Waymo divisor out of range", {waymoDivisor});
  const humanFactor = 1 / waymoDivisor;
  const estAtMiles = miles => scaleEstimate(waymo.estAtMiles(miles), humanFactor);
  summaries.Humans = {
    company: "Humans",
    k: waymo.k,
    miles: waymo.miles,
    est: estAtMiles(waymo.miles),
    estAtMiles,
    bounds: waymo.bounds,
    waymoDivisor,
  };
  return summaries;
}

function fmtDivisor(divisor) {
  return "1/" + Number(divisor).toFixed(1).replace(/\\.0$/, "");
}

function summaryHeader(summary) {
  const formatters = {
    Tesla: s =>
      `${s.company}: ${s.k} incidents in ${Math.round(s.miles).toLocaleString()} miles ⇒ ${fmtMiles(s.est.median)} miles per incident`,
    Waymo: s =>
      `${s.company}: ${s.k} incidents in ${Math.round(s.miles).toLocaleString()} miles ⇒ ${fmtMiles(s.est.median)} miles per incident`,
    Zoox: s =>
      `${s.company}: ${s.k} incidents in ${Math.round(s.miles).toLocaleString()} miles ⇒ ${fmtMiles(s.est.median)} miles per incident`,
    Humans: s =>
      `Humans: ${fmtMiles(s.est.median)} miles per incident (${fmtDivisor(s.waymoDivisor)} of Waymo)`,
  };
  const fn = formatters[summary.company];
  must(typeof fn === "function", "Missing summary header formatter", {company: summary.company});
  return fn(summary);
}

function updateAllEstimates() {
  for (const company of COMPANY_ORDER) updateEstimate(company);
}

function buildEstimator() {
  const container = byId("estimator");
  container.replaceChildren();
  const counts = countByCompany();

  for (const company of COMPANY_ORDER) {
    const cfg = COMPANIES[company];
    const k = counts[company] || 0;
    const panel = document.createElement("div");
    panel.className = "company-panel";
    panel.dataset.company = company;

    let html = `<h3 id="header-stats-${company}">${company}: ${k} incidents in 0 miles ⇒ ? miles per incident</h3>`;

    for (const s of cfg.sliders) {
      must(typeof s.tip === "string" && s.tip.length > 0,
        "slider missing tooltip", {company, sliderId: s.id});
      const tip = escAttr(s.tip);
      html += `
        <div class="slider-row">
          <label for="${s.id}" title="${tip}">${s.label}</label>
          <input type="range" id="${s.id}" min="${s.min}" max="${s.max}"
                 step="${s.step}" value="${s.value}" title="${tip}">
          <span class="val" id="${s.id}-val">${s.fmt(s.value)}</span>
        </div>`;
    }

    const axisMinTip = escAttr(AXIS_MIN_TIP);
    const axisMaxTip = escAttr(AXIS_MAX_TIP);
    const axisMinInput = axisInputId(company, "min");
    const axisMaxInput = axisInputId(company, "max");
    const axisMinValue = axisValueId(company, "min");
    const axisMaxValue = axisValueId(company, "max");
    html += `
      <div class="slider-row">
        <label for="${axisMinInput}" title="${axisMinTip}">${AXIS_MIN_LABEL}</label>
        <input type="range" id="${axisMinInput}" min="0" max="99" step="1"
               value="${AXIS_MIN_DEFAULT_PCT}" title="${axisMinTip}">
        <span class="val" id="${axisMinValue}">0</span>
      </div>
      <div class="slider-row">
        <label for="${axisMaxInput}" title="${axisMaxTip}">${AXIS_MAX_LABEL}</label>
        <input type="range" id="${axisMaxInput}" min="1" max="100" step="1"
               value="${AXIS_MAX_DEFAULT_PCT}" title="${axisMaxTip}">
        <span class="val" id="${axisMaxValue}">0</span>
      </div>`;

    html += `<div class="result-box" id="result-${company}"></div>`;
    panel.innerHTML = html;
    container.appendChild(panel);

    // Attach slider listeners
    for (const s of cfg.sliders) {
      const input = byId(s.id);
      const valSpan = byId(s.id + "-val");
      input.addEventListener("input", () => {
        valSpan.textContent = s.fmt(Number(input.value));
        updateAllEstimates();
      });
    }
    const axisMinNode = byId(axisInputId(company, "min"));
    const axisMaxNode = byId(axisInputId(company, "max"));
    syncAxisSliderBounds(company);
    axisMinNode.addEventListener("input", () => {
      syncAxisSliderBounds(company);
      updateAllEstimates();
    });
    axisMaxNode.addEventListener("input", () => {
      syncAxisSliderBounds(company);
      updateAllEstimates();
    });
  }
  updateAllEstimates();
}

function updateEstimate(company) {
  const cfg = COMPANIES[company];
  must(cfg !== undefined, "Unknown company config", {company});
  const counts = countByCompany();
  const summaries = companySummaries(counts);
  const thisSummary = summaries[company];
  must(thisSummary !== undefined, "Missing summary for company", {company});
  const peers = COMPANY_ORDER.filter(name => name !== company).map(name => summaries[name]);
  const miles = thisSummary.miles;
  const est = thisSummary.est;
  byId("header-stats-" + company).textContent = summaryHeader(thisSummary);

  const box = byId("result-" + company);
  const axis = axisWindow(company, thisSummary.bounds);
  const xMin = axis.xMin;
  const xMax = axis.xMax;
  byId(axisValueId(company, "min")).textContent = Math.round(xMin).toLocaleString();
  byId(axisValueId(company, "max")).textContent = Math.round(xMax).toLocaleString();
  const samples = sampledEstimates(thisSummary.estAtMiles, xMin, xMax, 40);
  const yMin = Math.min(...samples.map(s => s.est.lo), ...peers.map(p => p.est.median));
  const yMax = Math.max(...samples.map(s => s.est.hi), ...peers.map(p => p.est.median));
  const svgW = 520;
  const svgH = 220;
  const mLeft = 56;
  const mRight = 12;
  const mTop = 10;
  const mBot = 40;
  const pW = svgW - mLeft - mRight;
  const pH = svgH - mTop - mBot;
  const mapX = x => scaleLinear(x, xMin, xMax, mLeft, mLeft + pW);
  const mapY = y => scaleLinear(y, yMin, yMax, mTop + pH, mTop);
  const pointX = mapX(miles);
  const pointY = mapY(est.median);
  const xTicks = [xMin, (xMin + xMax) / 2, xMax];
  const xTickAnchors = ["start", "middle", "end"];
  const yTicks = [yMin, (yMin + yMax) / 2, yMax];
  const band = bandPath(samples, mapX, mapY);
  const path = medianPath(samples, mapX, mapY);
  const peerLabels = layoutRefLabels(peers, mapY, mTop, pH);

  box.innerHTML = `
    <svg class="graph-svg" viewBox="0 0 ${svgW} ${svgH}">
      ${xTicks.map((x, i) => `
        <line class="graph-grid" x1="${mapX(x)}" y1="${mTop}" x2="${mapX(x)}" y2="${mTop + pH}"></line>
        <text class="graph-tick" x="${mapX(x)}" y="${svgH - 16}" text-anchor="${xTickAnchors[i]}">${Math.round(x).toLocaleString()}</text>
      `).join("")}
      ${yTicks.map(y => `
        <line class="graph-grid" x1="${mLeft}" y1="${mapY(y)}" x2="${mLeft + pW}" y2="${mapY(y)}"></line>
        <text class="graph-tick" x="${mLeft - 8}" y="${mapY(y) + 4}" text-anchor="end">${fmtMiles(y)}</text>
      `).join("")}
      <line class="graph-axis" x1="${mLeft}" y1="${mTop}" x2="${mLeft}" y2="${mTop + pH}"></line>
      <line class="graph-axis" x1="${mLeft}" y1="${mTop + pH}" x2="${mLeft + pW}" y2="${mTop + pH}"></line>
      <path class="graph-band" d="${band}"></path>
      <path class="graph-line" d="${path}"></path>
      ${peerLabels.map(p => `
        <line class="graph-refline" x1="${mLeft}" y1="${p.lineY}" x2="${mLeft + pW}" y2="${p.lineY}" style="stroke:${COMPANY_COLORS[p.company]}"></line>
        <text class="graph-reflabel" x="${mLeft + pW - 4}" y="${p.labelY}" text-anchor="end" style="fill:${COMPANY_COLORS[p.company]}">${p.company}: ${fmtMiles(p.est.median)}</text>
      `).join("")}
      <circle class="graph-point" cx="${pointX}" cy="${pointY}" r="5"></circle>
      <text class="graph-label" x="${mLeft + pW / 2}" y="${svgH - 2}" text-anchor="middle">Total Autonomous Miles</text>
      <text class="graph-label" x="12" y="${mTop + pH / 2}" transform="rotate(-90 12 ${mTop + pH / 2})" text-anchor="middle">Miles per incident</text>
    </svg>
  `;
}

function fmtMiles(n) {
  if (n >= 1e6) return (n / 1e6).toFixed(1) + "M";
  if (n >= 1e3) return (n / 1e3).toFixed(1) + "K";
  return Math.round(n).toLocaleString();
}

function csvUnquote(field) {
  const quoted = field.startsWith("\"") && field.endsWith("\"");
  return quoted ? field.slice(1, -1).replace(/""/g, "\"") : field;
}

function parseVmtCsv(text) {
  const lines = text.split(/\r?\n/).map(line => line.trimEnd());
  must(lines.length > 1, "vmt.csv must include header and rows");
  must(lines[0] === "company,period_start,period_end,days_in_period,min_vmt,best_vmt,max_vmt,source_anchors",
    "vmt.csv header mismatch", {header: lines[0]});
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line === "") continue;
    const hit = /^([^,]+),(\d{4}-\d{2}-\d{2}),(\d{4}-\d{2}-\d{2}),(\d+),(\d+),(\d+),(\d+),(.*)$/.exec(line);
    must(hit !== null, "Malformed vmt.csv row", {lineNo: i + 1, line});
    const company = hit[1];
    must(ADS_COMPANIES.includes(company), "vmt.csv has unknown company", {company});
    const days = Number(hit[4]);
    const minVmt = Number(hit[5]);
    const bestVmt = Number(hit[6]);
    const maxVmt = Number(hit[7]);
    must(Number.isInteger(days) && days > 0, "vmt days_in_period invalid", {lineNo: i + 1, days});
    must(Number.isInteger(minVmt) && Number.isInteger(bestVmt) && Number.isInteger(maxVmt),
      "vmt values must be integers", {lineNo: i + 1, minVmt, bestVmt, maxVmt});
    must(minVmt >= 0 && minVmt <= bestVmt && bestVmt <= maxVmt,
      "vmt values must satisfy min <= best <= max", {lineNo: i + 1, minVmt, bestVmt, maxVmt});
    rows.push({
      company,
      periodStart: hit[2],
      periodEnd: hit[3],
      daysInPeriod: days,
      minVmt,
      bestVmt,
      maxVmt,
      sourceAnchors: csvUnquote(hit[8]),
    });
  }
  must(rows.length > 0, "vmt.csv has no data rows");
  return rows;
}

function monthKeyFromIsoDate(iso) {
  must(/^\d{4}-\d{2}-\d{2}$/.test(iso), "Invalid ISO date", {iso});
  const month = iso.slice(0, 7);
  must(YM_RE.test(month), "Invalid YYYY-MM key", {month});
  return month;
}

function monthKeyFromIncidentLabel(label) {
  const hit = /^([A-Z]{3})-(\d{4})$/.exec(label);
  must(hit !== null, "Invalid incident month label", {label});
  const month = MONTH_TOKENS[hit[1]];
  must(month !== undefined, "Unknown incident month token", {label});
  return `${hit[2]}-${String(month).padStart(2, "0")}`;
}

function speedBinForIncident(speed) {
  if (speed === null) return "unknown";
  if (speed === 0) return "0";
  if (speed <= 10) return "1-10";
  if (speed <= 30) return "11-30";
  return "31+";
}

function emptySpeedBins() {
  return {"31+": 0, "11-30": 0, "1-10": 0, unknown: 0, "0": 0};
}

function linearTicks(min, max, count) {
  const out = [];
  for (let i = 0; i <= count; i++) {
    out.push(min + (max - min) * i / count);
  }
  return out;
}

function nonstationaryIncidentCount(speeds) {
  return speeds["1-10"] + speeds["11-30"] + speeds["31+"];
}

function fmtCount(n) {
  const rounded = Math.round(n * 10) / 10;
  if (Number.isInteger(rounded)) return rounded.toLocaleString();
  return rounded.toFixed(1);
}

function monthScale(month) {
  return PARTIAL_MONTH_SCALE[month] || 1;
}

function monthLabel(month) {
  return monthScale(month) === 1 ? month : month + "*";
}

function scaleSpeeds(speeds, factor) {
  return {
    "31+": speeds["31+"] * factor,
    "11-30": speeds["11-30"] * factor,
    "1-10": speeds["1-10"] * factor,
    unknown: speeds.unknown * factor,
    "0": speeds["0"] * factor,
  };
}

function fmtWhole(n) {
  return Math.round(n).toLocaleString();
}

function scaledCompanyMonthRows(series, company) {
  return series.points.map((point, i) => {
    const rec = point.companies[company];
    const factor = monthScale(series.months[i]);
    return {
      vmt: {
        minVmt: rec.vmt.minVmt * factor,
        bestVmt: rec.vmt.bestVmt * factor,
        maxVmt: rec.vmt.maxVmt * factor,
      },
      incidents: {
        total: rec.incidents.total * factor,
        speeds: scaleSpeeds(rec.incidents.speeds, factor),
      },
    };
  });
}

function monthlySummaryRows(series) {
  return ADS_COMPANIES.map(company => {
    const rows = scaledCompanyMonthRows(series, company);
    const vmtMin = rows.reduce((sum, row) => sum + row.vmt.minVmt, 0);
    const vmtBest = rows.reduce((sum, row) => sum + row.vmt.bestVmt, 0);
    const vmtMax = rows.reduce((sum, row) => sum + row.vmt.maxVmt, 0);
    const incTotal = rows.reduce((sum, row) => sum + row.incidents.total, 0);
    const incNonstationary = rows.reduce(
      (sum, row) => sum + nonstationaryIncidentCount(row.incidents.speeds), 0);
    must(incTotal > 0, "summary total incidents must be positive", {company, incTotal});
    must(incNonstationary > 0,
      "summary nonstationary incidents must be positive", {company, incNonstationary});
    return {
      company,
      vmtMin,
      vmtBest,
      vmtMax,
      incTotal,
      incNonstationary,
      milesPerIncident: vmtBest / incTotal,
      milesPerNonstationaryIncident: vmtBest / incNonstationary,
    };
  });
}

function monthSeriesData() {
  must(vmtRows.length > 0, "month series requires vmtRows");
  const monthSet = new Set();
  const vmtByKey = {};
  for (const row of vmtRows) {
    const month = monthKeyFromIsoDate(row.periodStart);
    const key = row.company + "|" + month;
    must(vmtByKey[key] === undefined, "Duplicate VMT row for company-month", {key});
    vmtByKey[key] = row;
    monthSet.add(month);
  }

  const incidentsByKey = {};
  for (const inc of incidents) {
    must(ADS_COMPANIES.includes(inc.company), "incidents.json has unknown ADS company", {company: inc.company});
    const month = monthKeyFromIncidentLabel(inc.date);
    if (!monthSet.has(month)) continue;
    const key = inc.company + "|" + month;
    let rec = incidentsByKey[key];
    if (rec === undefined) {
      rec = {total: 0, speeds: emptySpeedBins()};
      incidentsByKey[key] = rec;
    }
    rec.total += 1;
    const bin = speedBinForIncident(inc.speed);
    rec.speeds[bin] += 1;
  }

  const months = [...monthSet].sort();
  must(months.length > 0, "No months to render");
  const points = [];
  for (const month of months) {
    const companies = {};
    for (const company of ADS_COMPANIES) {
      const key = company + "|" + month;
      const vmt = vmtByKey[key];
      must(vmt !== undefined, "Missing VMT for company-month", {company, month});
      const inc = incidentsByKey[key] || {total: 0, speeds: emptySpeedBins()};
      const k = inc.total;
      const hasIncidents = k > 0;
      must(vmt.bestVmt > 0 && vmt.maxVmt > 0, "best/max vmt must be positive", {company, month});
      must(!hasIncidents || vmt.minVmt > 0,
        "Positive incidents require positive min_vmt", {company, month, minVmt: vmt.minVmt});
      companies[company] = {
        vmt,
        incidents: inc,
      };
    }
    points.push({month, companies});
  }
  return {months, points};
}

function drawSingleMonthAxes(
  months, svgH, mLeft, mTop, pW, pH, mapX, yTicks, mapY, yFmt, yLabel,
) {
  const axisY = mTop + pH;
  return `
    ${months.map((month, i) => `
      <line class="month-grid" x1="${mapX(i)}" y1="${mTop}" x2="${mapX(i)}" y2="${axisY}"></line>
      <text class="month-tick" x="${mapX(i)}" y="${svgH - 16}" text-anchor="middle">${monthLabel(month)}</text>
    `).join("")}
    ${yTicks.map(y => `
      <line class="month-grid" x1="${mLeft}" y1="${mapY(y)}" x2="${mLeft + pW}" y2="${mapY(y)}"></line>
      <text class="month-tick" x="${mLeft - 8}" y="${mapY(y) + 4}" text-anchor="end">${yFmt(y)}</text>
    `).join("")}
    <line class="month-axis" x1="${mLeft}" y1="${mTop}" x2="${mLeft}" y2="${axisY}"></line>
    <line class="month-axis" x1="${mLeft}" y1="${axisY}" x2="${mLeft + pW}" y2="${axisY}"></line>
    <text class="month-label" x="12" y="${mTop + pH / 2}" transform="rotate(-90 12 ${mTop + pH / 2})" text-anchor="middle">${yLabel}</text>
  `;
}

function renderAllCompaniesMpiChart(series) {
  const svgW = 900;
  const svgH = 250;
  const mLeft = 68;
  const mRight = 16;
  const mTop = 14;
  const mBot = 40;
  const pW = svgW - mLeft - mRight;
  const pH = svgH - mTop - mBot;
  const metricDefs = [
    { key: "all", dash: "", markerFill: "solid" },
    { key: "nonstationary", dash: "5 4", markerFill: "hollow" },
  ];
  const countByMetric = {
    all: rec => rec.incidents.total,
    nonstationary: rec => nonstationaryIncidentCount(rec.incidents.speeds),
  };

  const seriesRows = [];
  let yMax = 1;
  for (const company of ADS_COMPANIES) {
    for (const metric of metricDefs) {
      const countFn = countByMetric[metric.key];
      must(typeof countFn === "function", "missing count fn for metric", {metric: metric.key});
      const vals = series.points.map(point => {
        const rec = point.companies[company];
        const k = countFn(rec);
        if (k <= 0) return null;
        const est = {
          lo: rec.vmt.minVmt / k,
          best: rec.vmt.bestVmt / k,
          hi: rec.vmt.maxVmt / k,
        };
        yMax = Math.max(yMax, est.hi);
        return est;
      });
      seriesRows.push({company, metric, vals});
    }
  }

  const yTicks = linearTicks(0, yMax, 4);
  const mapX = idx => scaleLinear(idx, 0, series.months.length - 1, mLeft, mLeft + pW);
  const mapY = y => scaleLinear(y, 0, yMax, mTop + pH, mTop);

  const lines = seriesRows.map(row => {
    let d = "";
    let penDown = false;
    for (let i = 0; i < row.vals.length; i++) {
      const rec = row.vals[i];
      if (rec === null) {
        penDown = false;
        continue;
      }
      d += `${penDown ? " L " : "M "}${mapX(i).toFixed(2)} ${mapY(rec.best).toFixed(2)}`;
      penDown = true;
    }
    const dash = row.metric.dash === "" ? "" : `stroke-dasharray:${row.metric.dash};`;
    return `<path class="month-mpi-all-line" d="${d}" style="stroke:${MONTHLY_COMPANY_COLORS[row.company]};${dash}"></path>`;
  }).join("");

  const marks = seriesRows.map(row =>
    row.vals.map((rec, i) => {
      if (rec === null) return "";
      const x = mapX(i);
      const yBest = mapY(rec.best);
      const yLo = mapY(rec.lo);
      const yHi = mapY(rec.hi);
      const color = MONTHLY_COMPANY_COLORS[row.company];
      const fill = row.metric.markerFill === "solid" ? color : "#fff";
      return `
        <line class="month-err" x1="${x}" y1="${yLo}" x2="${x}" y2="${yHi}" style="stroke:${color}"></line>
        <line class="month-err" x1="${x - 3}" y1="${yLo}" x2="${x + 3}" y2="${yLo}" style="stroke:${color}"></line>
        <line class="month-err" x1="${x - 3}" y1="${yHi}" x2="${x + 3}" y2="${yHi}" style="stroke:${color}"></line>
        <circle class="month-dot" cx="${x}" cy="${yBest}" r="3.1" style="fill:${fill};stroke:${color}"></circle>
      `;
    }).join("")
  ).join("");

  return `
    <svg class="month-svg" viewBox="0 0 ${svgW} ${svgH}">
      ${drawSingleMonthAxes(
        series.months, svgH, mLeft, mTop, pW, pH, mapX, yTicks, mapY, fmtMiles, "miles per incident",
      )}
      ${lines}
      ${marks}
    </svg>
  `;
}

function drawDualMonthAxes(
  months, svgW, svgH, mLeft, mTop, pW, pH, mapX,
  leftTicks, rightTicks, mapLeftY, mapRightY, leftFmt, rightFmt, leftLabel, rightLabel,
) {
  const axisY = mTop + pH;
  const rightX = mLeft + pW;
  const midY = mTop + pH / 2;
  return `
    ${months.map((month, i) => `
      <line class="month-grid" x1="${mapX(i)}" y1="${mTop}" x2="${mapX(i)}" y2="${axisY}"></line>
      <text class="month-tick" x="${mapX(i)}" y="${svgH - 16}" text-anchor="middle">${monthLabel(month)}</text>
    `).join("")}
    ${leftTicks.map(y => `
      <line class="month-grid" x1="${mLeft}" y1="${mapLeftY(y)}" x2="${rightX}" y2="${mapLeftY(y)}"></line>
      <text class="month-tick" x="${mLeft - 8}" y="${mapLeftY(y) + 4}" text-anchor="end">${leftFmt(y)}</text>
    `).join("")}
    <line class="month-axis" x1="${mLeft}" y1="${mTop}" x2="${mLeft}" y2="${axisY}"></line>
    <line class="month-axis" x1="${mLeft}" y1="${axisY}" x2="${rightX}" y2="${axisY}"></line>
    <text class="month-label" x="12" y="${midY}" transform="rotate(-90 12 ${midY})" text-anchor="middle">${leftLabel}</text>
  `;
}

function renderCompanyMonthlyChart(series, company) {
  const svgW = 900;
  const svgH = 250;
  const mLeft = 68;
  const mRight = 24;
  const mTop = 14;
  const mBot = 48;
  const pW = svgW - mLeft - mRight;
  const pH = svgH - mTop - mBot;
  const rows = scaledCompanyMonthRows(series, company);
  const vmtMax = Math.max(1, ...rows.map(row => row.vmt.maxVmt));
  const incidentMax = Math.max(1, ...rows.map(row => row.incidents.total));
  const leftTicks = linearTicks(0, vmtMax, 4);
  const rightTicks = linearTicks(0, incidentMax, 4);
  const monthStep = pW / ((series.months.length - 1) || 1);
  const barW = Math.min(30, monthStep * 0.56);
  const xPad = barW / 2 + 2; // inset so edge bars don't overlap axes
  const mapX = idx => scaleLinear(idx, 0, series.months.length - 1, mLeft + xPad, mLeft + pW - xPad);
  const mapVmtY = y => scaleLinear(y, 0, vmtMax, mTop + pH, mTop);
  const mapIncidentY = y => scaleLinear(y, 0, incidentMax, mTop + pH, mTop);
  const vmtColor = MONTHLY_COMPANY_COLORS[company];

  const bars = [];
  const barCounts = [];
  const barTotals = [];
  for (let i = 0; i < series.points.length; i++) {
    const x = mapX(i) - barW / 2;
    const rec = rows[i].incidents;
    let stack = 0;
    for (const bin of SPEED_BINS) {
      const count = rec.speeds[bin];
      const next = stack + count;
      const y0 = mapIncidentY(stack);
      const y1 = mapIncidentY(next);
      const h = y0 - y1;
      stack = next;
      if (h <= 0) continue;
      bars.push(`
        <rect class="month-inc-bar" x="${x.toFixed(2)}" y="${y1.toFixed(2)}" width="${barW.toFixed(2)}" height="${h.toFixed(2)}"
              fill="${SPEED_BIN_COLORS[company][bin]}" stroke="${vmtColor}" stroke-width="0.8"></rect>
      `);
      const centerY = y1 + h / 2;
      barCounts.push(`
        <text class="month-inc-count" x="${(x + barW / 2).toFixed(2)}" y="${centerY.toFixed(2)}">${fmtCount(count)}</text>
      `);
    }
    if (rec.total > 0) {
      const labelX = x + barW / 2;
      const labelY = Math.max(mapIncidentY(rec.total) - 7, mTop + 7);
      barTotals.push(`<text class="month-inc-total" x="${labelX.toFixed(2)}" y="${labelY.toFixed(2)}">${fmtCount(rec.total)}</text>`);
    }
  }

  let vmtPath = "";
  for (let i = 0; i < series.points.length; i++) {
    const y = mapVmtY(rows[i].vmt.bestVmt);
    vmtPath += `${i ? " L " : "M "}${mapX(i).toFixed(2)} ${y.toFixed(2)}`;
  }

  const vmtMarks = rows.map((row, i) => {
    const rec = row.vmt;
    const x = mapX(i);
    const yBest = mapVmtY(rec.bestVmt);
    const yLo = mapVmtY(rec.minVmt);
    const yHi = mapVmtY(rec.maxVmt);
    return `
      <line class="month-err" x1="${x}" y1="${yLo}" x2="${x}" y2="${yHi}" style="stroke:${vmtColor}"></line>
      <line class="month-err" x1="${x - 3}" y1="${yLo}" x2="${x + 3}" y2="${yLo}" style="stroke:${vmtColor}"></line>
      <line class="month-err" x1="${x - 3}" y1="${yHi}" x2="${x + 3}" y2="${yHi}" style="stroke:${vmtColor}"></line>
      <circle class="month-dot" cx="${x}" cy="${yBest}" r="3.3" style="fill:${vmtColor}"></circle>
    `;
  }).join("");

  return `
    <svg class="month-svg" viewBox="0 0 ${svgW} ${svgH}">
      ${bars.join("")}
      ${barCounts.join("")}
      ${barTotals.join("")}
      <path class="month-vmt-line" d="${vmtPath}" style="stroke:${vmtColor}"></path>
      ${vmtMarks}
      ${drawDualMonthAxes(
        series.months, svgW, svgH, mLeft, mTop, pW, pH, mapX,
        leftTicks, rightTicks, mapVmtY, mapIncidentY,
        fmtMiles, fmtCount, "Vehicle Miles Traveled (VMT)", "incident count",
      )}
    </svg>
  `;
}

function renderMonthlySummary(series) {
  // TO-DO: Human vet all new end-user copy in this summary box.
  const rows = monthlySummaryRows(series);
  return `
    <div class="month-summary-title">Total summary</div>
    <table>
      <thead>
        <tr>
          <th>Company</th>
          <th>VMT min</th>
          <th>VMT best</th>
          <th>VMT max</th>
          <th>Total incidents</th>
          <th>Nonstationary incidents</th>
          <th>Miles per incident</th>
          <th>Miles per nonstationary incident</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(row => `
          <tr>
            <td>${row.company}</td>
            <td>${fmtWhole(row.vmtMin)}</td>
            <td>${fmtWhole(row.vmtBest)}</td>
            <td>${fmtWhole(row.vmtMax)}</td>
            <td>${fmtCount(row.incTotal)}</td>
            <td>${fmtCount(row.incNonstationary)}</td>
            <td>${fmtWhole(row.milesPerIncident)}</td>
            <td>${fmtWhole(row.milesPerNonstationaryIncident)}</td>
          </tr>
        `).join("")}
      </tbody>
    </table>
  `;
}

function renderMonthlyLegends() {
  byId("month-legend-mpi-companies").innerHTML = ADS_COMPANIES.map(company => `
    <span class="month-legend-item">
      <span class="month-chip" style="background:${MONTHLY_COMPANY_COLORS[company]}"></span>${company}
    </span>
  `).join("");

  byId("month-legend-mpi-lines").innerHTML = `
    <span class="month-legend-item">
      <span class="month-linekey solid"></span>Miles per incident
    </span>
    <span class="month-legend-item">
      <span class="month-linekey dashed"></span>Miles per nonstationary incident
    </span>
    <span class="month-legend-item">*: Partial months are scaled to full-month equivalents</span>
  `;

  byId("month-legend-lines").innerHTML = `
    <span class="month-legend-item">
      <span class="month-linekey solid"></span>VMT (best)
    </span>
    <span class="month-legend-item">
      <span class="month-chip" style="background:#a6adbb"></span>Incidents (stacked)
    </span>
  `;

  const speedLegendColor = {
    unknown: "#383c46",
    "31+": "#707070",
    "11-30": "#989898",
    "1-10": "#bbbbbb",
    "0": "#d9d9d9",
  };
  byId("month-legend-speed").innerHTML = SPEED_BINS.map(bin => `
    <span class="month-legend-item">
      <span class="month-chip" style="background:${speedLegendColor[bin]}"></span>${SPEED_LABELS[bin]}
    </span>
  `).join("");
}

function buildMonthlyViews() {
  const series = monthSeriesData();
  byId("chart-mpi-all").innerHTML = renderAllCompaniesMpiChart(series);
  byId("chart-company-series").innerHTML = ADS_COMPANIES.map(company => `
    <div class="month-chart">
      <h3>${company}</h3>
      ${renderCompanyMonthlyChart(series, company)}
    </div>
  `).join("");
  renderMonthlyLegends();
  byId("month-summary-box").innerHTML = renderMonthlySummary(series);
}

// --- Fault fraction data ---

function parseFaultfracCsv(text) {
  const lines = text.split(/\r?\n/);
  must(lines.length > 1, "faultfrac.csv must include header and rows");
  const header = lines[0].trim();
  must(header === "Report ID,ffclaude,ffcodex,ffgemini,rclaude,rcodex,rgemini",
    "faultfrac.csv header mismatch", {header});
  const data = {};
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line === "") continue;
    // Parse CSV respecting quoted fields
    const fields = [];
    let pos = 0;
    while (pos < line.length) {
      if (line[pos] === '"') {
        pos++;
        let val = "";
        while (pos < line.length) {
          if (line[pos] === '"' && line[pos + 1] === '"') {
            val += '"';
            pos += 2;
          } else if (line[pos] === '"') {
            pos++;
            break;
          } else {
            val += line[pos];
            pos++;
          }
        }
        if (pos < line.length && line[pos] === ',') pos++;
        fields.push(val);
      } else {
        const next = line.indexOf(',', pos);
        if (next === -1) {
          fields.push(line.slice(pos));
          pos = line.length;
        } else {
          fields.push(line.slice(pos, next));
          pos = next + 1;
        }
      }
    }
    must(fields.length === 7, "faultfrac.csv row has wrong field count",
      {lineNo: i + 1, count: fields.length});
    data[fields[0]] = {
      claude: Number(fields[1]),
      codex: Number(fields[2]),
      gemini: Number(fields[3]),
      rclaude: fields[4],
      rcodex: fields[5],
      rgemini: fields[6],
    };
  }
  return data;
}

function faultWeights() {
  const wc = Number(byId("w-claude").value);
  const wo = Number(byId("w-codex").value);
  const wg = Number(byId("w-gemini").value);
  return {claude: wc, codex: wo, gemini: wg};
}

function weightedFault(reportId) {
  const fd = faultData[reportId];
  if (!fd) return null;
  const w = faultWeights();
  const total = w.claude + w.codex + w.gemini;
  if (total === 0) return null;
  return (w.claude * fd.claude + w.codex * fd.codex + w.gemini * fd.gemini) / total;
}

function faultColor(frac) {
  // Green (0) -> Yellow (0.5) -> Red (1)
  if (frac <= 0.5) {
    const r = Math.round(255 * (frac / 0.5));
    return `rgb(${r}, 180, 60)`;
  }
  const g = Math.round(180 * (1 - (frac - 0.5) / 0.5));
  return `rgb(220, ${g}, 50)`;
}

function faultTooltip(reportId) {
  const fd = faultData[reportId];
  if (!fd) return "";
  return `Claude: ${fd.claude.toFixed(2)} — ${fd.rclaude}\nCodex: ${fd.codex.toFixed(2)} — ${fd.rcodex}\nGemini: ${fd.gemini.toFixed(2)} — ${fd.rgemini}`;
}

function initWeightSliders() {
  for (const model of ["claude", "codex", "gemini"]) {
    const input = byId("w-" + model);
    const valSpan = byId("w-" + model + "-val");
    input.addEventListener("input", () => {
      valSpan.textContent = input.value;
      renderTable();
    });
  }
}

// --- Incident Browser ---

let activeFilter = "All";
let sortCol = null;   // column key or null
let sortAsc = true;

const SORT_COLUMNS = [
  {key: "company",  val: r => r.company},
  {key: "date",     val: r => r.date},
  {key: "location", val: r => (r.city + ", " + r.state)},
  {key: "crashWith",val: r => r.crashWith},
  {key: "speed",    val: r => r.speed !== null ? r.speed : -1},
  {key: "fault",    val: r => { const f = weightedFault(r.reportId); return f !== null ? f : -1; }},
  {key: "severity", val: r => r.severity || ""},
  {key: "narrative", val: r => r.narrative || ""},
];

const HEADER_LABELS = ["Company", "Date", "Location", "Crash with", "Speed (mph)", "Fault", "Severity", "Narrative"];

function buildBrowser() {
  const counts = countByCompany();
  const filterDiv = byId("filters");
  filterDiv.replaceChildren();
  const companies = ["All", ...COMPANY_ORDER];
  for (const c of companies) {
    const btn = document.createElement("button");
    const n = c === "All" ? incidents.length : (counts[c] || 0);
    btn.textContent = `${c} (${n})`;
    btn.className = c === activeFilter ? "active" : "";
    btn.addEventListener("click", () => {
      activeFilter = c;
      buildBrowser();
    });
    filterDiv.appendChild(btn);
  }
  renderHeaders();
  renderTable();
}

function renderHeaders() {
  const thead = byId("incidents-head");
  const tr = document.createElement("tr");
  for (let i = 0; i < HEADER_LABELS.length; i++) {
    const th = document.createElement("th");
    const col = SORT_COLUMNS[i];
    let label = HEADER_LABELS[i];
    if (sortCol === col.key) {
      label += sortAsc ? " \u25B2" : " \u25BC";
    }
    th.textContent = label;
    th.addEventListener("click", () => {
      if (sortCol === col.key) {
        sortAsc = !sortAsc;
      } else {
        sortCol = col.key;
        sortAsc = true;
      }
      renderHeaders();
      renderTable();
    });
    tr.appendChild(th);
  }
  thead.replaceChildren(tr);
}

function renderTable() {
  const tbody = byId("incidents-body");
  let filtered = activeFilter === "All"
    ? [...incidents]
    : incidents.filter(r => r.company === activeFilter);

  if (sortCol !== null) {
    const colDef = SORT_COLUMNS.find(c => c.key === sortCol);
    if (colDef) {
      filtered.sort((a, b) => {
        const va = colDef.val(a);
        const vb = colDef.val(b);
        let cmp = 0;
        if (typeof va === "number" && typeof vb === "number") {
          cmp = va - vb;
        } else {
          cmp = String(va).localeCompare(String(vb));
        }
        return sortAsc ? cmp : -cmp;
      });
    }
  }

  byId("incident-count").textContent =
    `${filtered.length} incidents`;

  tbody.innerHTML = "";
  for (const r of filtered) {
    const tr = document.createElement("tr");
    const isCbi = r.narrativeCbi === "Y";
    const narrativeText = isCbi
      ? "[\"Confidential Business Information\"]"
      : (r.narrative || "");
    const narrativeClass = isCbi ? "narrative-cell cbi" : "narrative-cell";

    const fault = weightedFault(r.reportId);
    const faultHtml = fault !== null
      ? `<span class="fault-bar" style="width:${Math.round(fault * 40)}px;background:${faultColor(fault)}"></span>${fault.toFixed(2)}`
      : "—";
    const faultTip = escAttr(faultTooltip(r.reportId));

    tr.innerHTML = `
      <td>${escHtml(r.company)}</td>
      <td>${escHtml(r.date)}</td>
      <td>${escHtml(r.city)}, ${escHtml(r.state)}</td>
      <td>${escHtml(r.crashWith)}</td>
      <td>${escHtml(r.speed !== null ? String(r.speed) : "?")}</td>
      <td class="fault-cell" title="${faultTip}">${faultHtml}</td>
      <td>${escHtml(shortenSeverity(r.severity))}</td>
      <td class="${narrativeClass}">${escHtml(narrativeText)}</td>
    `;
    // Click to expand/collapse narrative
    const narrativeTd = tr.querySelector(".narrative-cell");
    must(narrativeTd !== null, "Missing narrative cell");
    narrativeTd.addEventListener("click", () => {
      narrativeTd.classList.toggle("expanded");
    });
    tbody.appendChild(tr);
  }
}

function shortenSeverity(s) {
  const rules = [
    ["No Injured", "No injury"],
    ["Minor W/O", "Minor injury"],
    ["Minor W/", "Minor injury (hosp.)"],
    ["Serious", "Serious"],
    ["Fatal", "Fatal"],
    ["Property", "Property only"],
  ];
  const hit = (s || "") && rules.find(([needle]) => s.includes(needle));
  return hit ? hit[1] : (s || "?");
}

function escHtml(s) {
  const d = document.createElement("div");
  d.textContent = s;
  return d.innerHTML;
}

function escAttr(s) {
  return escHtml(s).replace(/"/g, "&quot;");
}

// --- Init ---

Promise.all([
  fetch("incidents.json")
    .then(r => (must(r.ok, "Failed to load incidents.json", {status: r.status}), r.json())),
  fetch("quals/vmt.csv")
    .then(r => (must(r.ok, "Failed to load quals/vmt.csv", {status: r.status}), r.text())),
  fetch("faultfrac.csv")
    .then(r => (must(r.ok, "Failed to load faultfrac.csv", {status: r.status}), r.text())),
])
  .then(([incidentData, vmtCsvText, faultfracCsvText]) => {
    must(Array.isArray(incidentData), "incidents.json must be an array");
    for (const inc of incidentData) {
      must(inc !== null && typeof inc === "object", "incident must be an object");
      must(typeof inc.company === "string", "incident missing company");
      must(COMPANIES[inc.company] !== undefined,
        "incidents.json has unknown company", {company: inc.company});
    }
    incidents = incidentData;
    vmtRows = parseVmtCsv(vmtCsvText);
    faultData = parseFaultfracCsv(faultfracCsvText);
    initCiMassControl();
    initWeightSliders();
    buildEstimator();
    buildMonthlyViews();
    buildBrowser();
  });
</script>
</body>
</html>
